<!DOCTYPE html><html class="theme-next gemini use-motion" lang="zh-Hans,US,JP,default"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css"><meta name="keywords" content="笔记,队列,lock-free,"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2"><meta name="description" content="¶无锁队列¶概念：通常队列要实现安全的并发访问，需要对入队和出队方法加锁，例如在基于链表实现的队列中，入队和出队都涉及到头/尾节点指针的操作，不安全的并发控制很容易导致读取到错误数据甚至破坏链表结构例如线程A插入数据x , 获取到当前的尾节点 tail ,此时线程 B插入数据y ，将尾节点更新为为值为y的节点 ，而后线程 A 又将旧的尾节点更新，这就导致丢失了线程B插入的节点 y在多线程并发访问的"><meta name="keywords" content="笔记,队列,lock-free"><meta property="og:type" content="article"><meta property="og:title" content="无锁队列"><meta property="og:url" content="https://NextConner.github.io/joker/无锁队列/index.html"><meta property="og:site_name" content="Joker With Time Passing!"><meta property="og:description" content="¶无锁队列¶概念：通常队列要实现安全的并发访问，需要对入队和出队方法加锁，例如在基于链表实现的队列中，入队和出队都涉及到头/尾节点指针的操作，不安全的并发控制很容易导致读取到错误数据甚至破坏链表结构例如线程A插入数据x , 获取到当前的尾节点 tail ,此时线程 B插入数据y ，将尾节点更新为为值为y的节点 ，而后线程 A 又将旧的尾节点更新，这就导致丢失了线程B插入的节点 y在多线程并发访问的"><meta property="og:locale" content="zh-Hans"><meta property="og:image" content="https://nextconner.github.io/joker/无锁队列/..%5Cjoker%5C%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97%5C200px-Circular_buffer.svg.png"><meta property="og:image" content="https://nextconner.github.io/joker/无锁队列/..%5Cjoker%5C%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97%5C400px-Circular_Buffer_Animation.gif"><meta property="og:updated_time" content="2020-06-23T13:58:53.084Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="无锁队列"><meta name="twitter:description" content="¶无锁队列¶概念：通常队列要实现安全的并发访问，需要对入队和出队方法加锁，例如在基于链表实现的队列中，入队和出队都涉及到头/尾节点指针的操作，不安全的并发控制很容易导致读取到错误数据甚至破坏链表结构例如线程A插入数据x , 获取到当前的尾节点 tail ,此时线程 B插入数据y ，将尾节点更新为为值为y的节点 ，而后线程 A 又将旧的尾节点更新，这就导致丢失了线程B插入的节点 y在多线程并发访问的"><meta name="twitter:image" content="https://nextconner.github.io/joker/无锁队列/..%5Cjoker%5C%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97%5C200px-Circular_buffer.svg.png"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Gemini",sidebar:{position:"left",display:"post",offset:12,offset_float:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!0,tabs:!0,motion:!0,duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="https://NextConner.github.io/joker/无锁队列/"><title>无锁队列 | Joker With Time Passing!</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">Joker With Time Passing!</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">Boy meets ambitions!</p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://NextConner.github.io/joker/无锁队列/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Joker Zou"><meta itemprop="description" content><meta itemprop="image" content="/uploads/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Joker With Time Passing!"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">无锁队列</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-22T21:29:12+08:00">2020-06-22 21:29:12 </time></span><span class="post-updated">&nbsp; | &nbsp; 更新于 <time itemprop="dateUpdated" datetime="2020-06-23T21:58:53+08:00" content="2020-06-23 21:58:53">2020-06-23 21:58:53 </time></span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><a href="/joker/无锁队列/#comments" itemprop="discussionUrl"><span class="post-comments-count disqus-comment-count" data-disqus-identifier="joker/无锁队列/" itemprop="commentCount"></span> </a></span><span class="post-meta-divider">|</span> <span class="page-pv"><i class="fa fa-file-o"></i> 阅读数 <span class="busuanzi-value" id="busuanzi_value_page_pv"></span></span><div class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">字数统计</span> <span class="post-count" title="字数统计">2.3k 字 </span><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长</span> <span title="阅读时长">9 分钟</span></div></div></header><div class="post-body" itemprop="articleBody"><h2 id="无锁队列"><a class="header-anchor" href="#无锁队列">¶</a>无锁队列</h2><hr><h3 id="概念："><a class="header-anchor" href="#概念：">¶</a>概念：</h3><ol><li><p>通常队列要实现安全的并发访问，需要对入队和出队方法加锁，例如在基于链表实现的队列中，入队和出队都涉及到头/尾节点指针的操作，不安全的并发控制很容易导致读取到错误数据甚至破坏链表结构</p></li><li><p>例如线程A插入数据x , 获取到<strong>当前</strong>的尾节点 tail ,此时线程 B插入数据y ，将<strong>尾节点更新</strong>为为值为y的节点 ，而后线程 A 又<strong>将旧的尾节点</strong>更新，这就导致丢失了线程B插入的节点 y</p></li><li><p>在多线程并发访问的情况下这是完全有可能发生的，解决这个问题可以直接在入队和出队方法加锁，例如使用<strong>synchronized</strong> 关键字控制对出入队方法的访问，这样可以实现并发控制，但是在软件工程里面，效率也是一个很重要的问题，锁的粒度越大，效率越低；反之亦然。</p></li><li><p><strong>无锁队列</strong>并不是真正的没有锁，而是使用<strong>CAS</strong>模拟出了细粒度的锁，控制线程间的共享变量的访问 – <em>我们在实现并发控制的时候，是没有必要锁住整个对象的</em> – 这样线程之间就可以安全地通信</p><a id="more"></a></li></ol><hr><h3 id="实现"><a class="header-anchor" href="#实现">¶</a>实现</h3><ol><li><p>实现思路是在入队和出对方法，对head和tail 节点进行修改的时候，多次通过CAS操作确认当前获取到的是否是正确的 head 和 tail 节点以及它们的next节点，确保插入和更新操作的正确性</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockFreeQueue</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//头尾节点</span></span><br><span class="line">    <span class="keyword">public</span> Node&lt;E&gt; head;</span><br><span class="line">    <span class="keyword">public</span> Node&lt;E&gt; tail;</span><br><span class="line"></span><br><span class="line">    LockFreeQueue() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//enQueue</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">enqueue</span><span class="params">(LockFreeQueue&lt;E&gt; queue, Integer value)</span> </span>&#123;</span><br><span class="line">        System.out.print(value+<span class="string">","</span>);</span><br><span class="line">        <span class="comment">//队列为空时</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node&lt;E&gt; inNode = <span class="keyword">new</span> Node(value);</span><br><span class="line">            inNode.next = <span class="keyword">null</span>;</span><br><span class="line">            head = inNode;</span><br><span class="line">            tail = inNode;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//新的尾节点</span></span><br><span class="line">        Node newNode = <span class="keyword">new</span> Node(value);</span><br><span class="line">        newNode.next = <span class="keyword">null</span>;</span><br><span class="line">        Node oldP;</span><br><span class="line">        Node next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//获取尾指针快照</span></span><br><span class="line">            oldP = tail;</span><br><span class="line">            next = oldP.next;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//判断尾指针是否已经变更</span></span><br><span class="line">            <span class="keyword">if</span> (!oldP.equals(tail)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//判断next指针是否已经变更，已经变更就重置尾节点</span></span><br><span class="line">            <span class="keyword">if</span> (next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                casNode(tail, oldP, next);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//cas设置尾节点next</span></span><br><span class="line">            <span class="keyword">if</span> (oldP.next == next) &#123;</span><br><span class="line">                oldP.next = newNode;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cas设置尾节点</span></span><br><span class="line">        <span class="keyword">if</span> (tail.equals(oldP)) &#123;</span><br><span class="line">            tail = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head == <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//CAS 操作更新节点值</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">casNode</span><span class="params">(Node&lt;E&gt; node, Node&lt;E&gt; oldVal, Node&lt;E&gt; newVal)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == oldVal || node.equals(oldVal)) &#123;</span><br><span class="line">            node = newVal;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//并发的deDueue</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">deQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        E out;</span><br><span class="line">        <span class="comment">//并发获取头节点</span></span><br><span class="line">        Node&lt;E&gt; oldHead = head;</span><br><span class="line">        Node&lt;E&gt; oldTail = tail;</span><br><span class="line">        Node&lt;E&gt; next = oldHead.next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//什么样的情况下认为head指针已经被移动了?</span></span><br><span class="line">            <span class="keyword">if</span> (oldHead != head) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//判断队列已空</span></span><br><span class="line">            <span class="keyword">if</span> (oldHead == tail &amp;&amp; next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                out = head.value;</span><br><span class="line">                head = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">return</span> out;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//判断head指针是否先于tail指针移动过</span></span><br><span class="line">            <span class="keyword">if</span> (oldHead == tail &amp;&amp; next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//尾指针没有移动到正确的位置</span></span><br><span class="line">                <span class="keyword">if</span>(tail == oldTail)&#123;</span><br><span class="line">                    tail = next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//正确获得了队列的快照</span></span><br><span class="line">            <span class="keyword">if</span>(head == oldHead)&#123;</span><br><span class="line">                head = next;</span><br><span class="line">                out =  oldHead.value;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//释放内存</span></span><br><span class="line">        oldHead = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现得很难看，尤其是deQueue 的方法和casNode，所以有的地方改成了简单的 if 判断实现CAS操作</p></li><li><p>先来回忆一下插入节点的操作，<strong>声明新的尾节点，获得当前尾节点，更新当前尾节点的next，更新队列尾节点为新插入的节点</strong>，所以并发访问队列入队的时候有这样几种情况：</p><ol><li>线程A获得尾节点之后，进行插入数据之前，尾节点已经被B线程更新了</li><li>线程A获得正确的尾节点之后，插入数据之前，next节点被B线程更新了</li></ol></li><li><p>对于上述的两种情况：</p><ol><li>线程A获取尾节点之后，判断当前的尾节点快照是否是队列的尾节点，否的话使用<strong>CAS</strong>操作进行更新并重新循环</li><li>线程A获取正确的尾节点之后，next节点并不指向null，因为线程B刚好更新了尾节点，CAS操作更新尾节点重新循环</li></ol></li><li><p>综上所述：<strong>并发访问入队方法，要保证每次插入新节点时，都是在正确的尾节点的基础上进行更新的</strong>，出队方法也类似</p></li><li><p>队列中出队的过程是：<strong>获取当前head节点，保存head节点的值，将 队列的head指针更新为 head.next ，head节点置空</strong>，同样并发访问出队方法会有下面这几种情况</p><ol><li>线程A获取head节点之后，出队之前head节点被更新(后移)了</li><li>线程A获取正确的 head 节点之后，出队之前，head节点先于tail节点移动了(会出现在只有一个节点的场景中，因为此时 head == tail )，需要更新tail节点</li></ol></li><li><p>其实相比处理入队的情况，出队似乎要简单一点;</p><ol><li>head节点被更新的情况下，需要重新循环更新head节点</li><li>head节点如果先于tail节点移动，只需要将tail节点更新到正确的位置</li></ol></li><li><p>最后就是更新队列的 head 节点为 head.next，并将旧的head节点置空</p></li></ol><hr><h3 id="优化"><a class="header-anchor" href="#优化">¶</a>优化</h3><ol><li><p>在队列使用中，声明一个dummy节点，可以省去一些边界条件的判断</p></li><li><p>对代码进行优化：</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockFreeQueue</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Node&lt;E&gt; head;</span><br><span class="line">    <span class="keyword">public</span> Node&lt;E&gt; tail;</span><br><span class="line"></span><br><span class="line">    LockFreeQueue() &#123;</span><br><span class="line"></span><br><span class="line">        Node&lt;E&gt; dummy = <span class="keyword">new</span> Node&lt;&gt;();</span><br><span class="line">        dummy.next = <span class="keyword">null</span>;</span><br><span class="line">        head = tail = dummy;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//enQueue</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">enqueue</span><span class="params">(LockFreeQueue&lt;E&gt; queue, Integer value)</span> </span>&#123;</span><br><span class="line">        System.out.print(value + <span class="string">","</span>);</span><br><span class="line">        <span class="comment">//新的尾节点</span></span><br><span class="line">        Node newNode = <span class="keyword">new</span> Node(value);</span><br><span class="line">        newNode.next = <span class="keyword">null</span>;</span><br><span class="line">        Node oldP;</span><br><span class="line">        Node next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//获取尾指针快照</span></span><br><span class="line">            oldP = tail;</span><br><span class="line">            next = oldP.next;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//判断尾指针是否已经变更</span></span><br><span class="line">            <span class="keyword">if</span> (!oldP.equals(tail)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//判断next指针是否已经变更，已经变更就重置尾节点</span></span><br><span class="line">            <span class="keyword">if</span> (next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                casNode(tail, oldP, next);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//cas设置尾节点next</span></span><br><span class="line">            <span class="keyword">if</span> (oldP.next == next) &#123;</span><br><span class="line">                oldP.next = newNode;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cas设置尾节点</span></span><br><span class="line">        <span class="keyword">if</span> (tail.equals(oldP)) &#123;</span><br><span class="line">            tail = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断队列为空的条件变了，当head.next == null时意味着没有任何节点存在</span></span><br><span class="line">        <span class="keyword">return</span> head.next == <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//CAS 操作更新节点值</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">casNode</span><span class="params">(Node&lt;E&gt; node, Node&lt;E&gt; oldVal, Node&lt;E&gt; newVal)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == oldVal || node.equals(oldVal)) &#123;</span><br><span class="line">            node = newVal;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//并发的deDueue</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">deQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        E out;</span><br><span class="line">        <span class="comment">//并发获取头节点</span></span><br><span class="line">        Node&lt;E&gt; oldHead = head;</span><br><span class="line">        Node&lt;E&gt; oldTail = tail;</span><br><span class="line">        Node&lt;E&gt; next = oldHead.next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//什么样的情况下认为head指针已经被移动了?</span></span><br><span class="line">            <span class="keyword">if</span> (oldHead != head) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//判断队列已空</span></span><br><span class="line">            <span class="keyword">if</span> (oldHead == tail &amp;&amp; next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//判断head指针是否先于tail指针移动过</span></span><br><span class="line">            <span class="keyword">if</span> (oldHead == tail &amp;&amp; next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//尾指针没有移动到正确的位置</span></span><br><span class="line">                <span class="keyword">if</span> (tail == oldTail) &#123;</span><br><span class="line">                    tail = next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//正确获得了队列的快照</span></span><br><span class="line">            <span class="keyword">if</span> (head == oldHead) &#123;</span><br><span class="line">                head = next;</span><br><span class="line">                <span class="comment">//因为head节点是dummy节点，不参与队列的操作，所以出队的是head.next</span></span><br><span class="line">                out = next.value;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        oldHead = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>主要是插入和删除节点的逻辑改变了，插入时不再判断是否空队列，删除节点需要讲将head.next 出队而不是 head本身</p></li></ol><hr><h3 id="基于环形数组实现的无锁队列"><a class="header-anchor" href="#基于环形数组实现的无锁队列">¶</a>基于环形数组实现的无锁队列</h3><ol><li><p>之前在学习数组的时候，也见到有描述说“基于环形数组可以实现高效的并发队列”，先抛开并发队列，理解清楚环形数组的概念</p></li><li><p>**Ring Buffer **：环形数组</p><ol><li><p>一种通过<strong>单个固定长度</strong>的缓冲过去实现的端到端相连的数据结构，基于结构特性适合用来做数据流缓冲</p></li><li><p><strong>这是抽象出来的缓冲区模型，现实中的计算机物理内存缓冲区并没有这样的实现，只是它的概念表示类似于一个环状</strong></p></li><li><p>它长得像这样:</p><p><img src="//NextConner.github.io/joker/无锁队列/..%5Cjoker%5C%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97%5C200px-Circular_buffer.svg.png" alt></p></li></ol></li><li><p><strong>特点和适用场景</strong>：</p><ol><li><p>我们知道一般的线性数组，每次有数据被移除时，都需要进行数组元素的移动以确保数组内存空间连续；而环形数组不需要考虑这一点，它没有固定的头和尾，它的头和尾元素是随着读写缓冲区的指针而变化的，下面是从WIKI上面复制过来的动图:</p><p><img src="//NextConner.github.io/joker/无锁队列/..%5Cjoker%5C%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97%5C400px-Circular_Buffer_Animation.gif" alt></p></li><li><p><strong>蓝色是读指针，红色是写指针</strong>，环形缓冲区的数据存储在 head~tail 之间，根据FIFO的特点：</p><ol><li>从head出读取数据时，head后移， 缓冲区数据范围变成了 head +1 ~ tail 的区域</li><li>向缓冲区插入一个数据后，缓冲区数据存储范围是 head + 1 ~ tail + 1 ；</li><li>删除和新增数据都不需要进行数据元素的移动</li><li>随着读写的交叉进行，<strong>环形缓冲区中的数据存储区域是在游动的，所以说环形缓冲没有固定的head和tail元素，它们随着读写情况不断发生变化</strong></li></ol></li></ol></li><li><p><strong>实现</strong>：</p><ol><li><p>通过 java 代码实现一个环形数组</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">      </span><br><span class="line"><span class="comment">//TODO</span></span><br></pre></td></tr></table></figure></li></ol></li></ol></div><footer class="post-footer"><div class="post-tags"><a href="/tags/笔记/" rel="tag"># 笔记</a> <a href="/tags/队列/" rel="tag"># 队列</a> <a href="/tags/lock-free/" rel="tag"># lock-free</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/joker/知识反刍-链表/" rel="next" title="知识反刍--链表"><i class="fa fa-chevron-left"></i> 知识反刍--链表</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/joker/LeetCode-BinaryTreeLevelOrderTraversal/" rel="prev" title="LeetCode-BinaryTreeLevelOrderTraversal">LeetCode-BinaryTreeLevelOrderTraversal <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"></div></div></div><div class="comments" id="comments"><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview">站点概览</li></ul><section class="site-overview sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/uploads/avatar.jpg" alt="Joker Zou"><p class="site-author-name" itemprop="name">Joker Zou</p><p class="site-description motion-element" itemprop="description">Follow your heart</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">35</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">4</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">40</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="links-of-author motion-element"></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#无锁队列"><span class="nav-number">1.</span> <span class="nav-text">¶无锁队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概念："><span class="nav-number">1.1.</span> <span class="nav-text">¶概念：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实现"><span class="nav-number">1.2.</span> <span class="nav-text">¶实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#优化"><span class="nav-number">1.3.</span> <span class="nav-text">¶优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基于环形数组实现的无锁队列"><span class="nav-number">1.4.</span> <span class="nav-text">¶基于环形数组实现的无锁队列</span></a></li></ol></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="copyright">&copy; <span itemprop="copyrightYear">2020</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Joker Zou</span></div><div class="powered-by">由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动</div><div class="theme-info">主题 - <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a></div><div class="busuanzi-count"><script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="site-uv">访客数 <span class="busuanzi-value" id="busuanzi_value_site_uv"></span> 只 </span><span class="site-pv"><i class="fa fa-eye"></i> 总访问量 <span class="busuanzi-value" id="busuanzi_value_site_pv"></span> 回</span></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script><script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script><script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script><script id="dsq-count-scr" src="https://jokerz.disqus.com/count.js" async></script><script type="text/javascript">var disqus_config=function(){this.page.url="https://NextConner.github.io/joker/无锁队列/",this.page.identifier="joker/无锁队列/",this.page.title="无锁队列"},d=document,s=d.createElement("script");s.src="https://jokerz.disqus.com/embed.js",s.setAttribute("data-timestamp",""+ +new Date),(d.head||d.body).appendChild(s)</script></body></html>