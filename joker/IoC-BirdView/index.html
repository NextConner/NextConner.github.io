<!DOCTYPE html><html class="theme-next gemini use-motion" lang="zh-Hans,US,JP,default"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css"><meta name="keywords" content="笔记,Spring,框架,"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2"><meta name="description" content="Ioc 概览Bean 属性定制:Spring 框架提供了一系列用于定制 Bean 的接口, 主要是 Bean 生命周期相关的回调方法（ Lifecycle Callbacks ）生命周期相关的回调方法:为了和Spring 对Bean 的管理相互影响，可以通过实现 InitializingBean 和 DisposableBean 接口，分别定义 Bean 的 afterPropertiesSet("><meta name="keywords" content="笔记,Spring,框架"><meta property="og:type" content="article"><meta property="og:title" content="IoC BirdView"><meta property="og:url" content="https://NextConner.github.io/joker/IoC-BirdView/index.html"><meta property="og:site_name" content="Joker With Time Passing!"><meta property="og:description" content="Ioc 概览Bean 属性定制:Spring 框架提供了一系列用于定制 Bean 的接口, 主要是 Bean 生命周期相关的回调方法（ Lifecycle Callbacks ）生命周期相关的回调方法:为了和Spring 对Bean 的管理相互影响，可以通过实现 InitializingBean 和 DisposableBean 接口，分别定义 Bean 的 afterPropertiesSet("><meta property="og:locale" content="zh-Hans"><meta property="og:updated_time" content="2020-05-11T15:33:43.220Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="IoC BirdView"><meta name="twitter:description" content="Ioc 概览Bean 属性定制:Spring 框架提供了一系列用于定制 Bean 的接口, 主要是 Bean 生命周期相关的回调方法（ Lifecycle Callbacks ）生命周期相关的回调方法:为了和Spring 对Bean 的管理相互影响，可以通过实现 InitializingBean 和 DisposableBean 接口，分别定义 Bean 的 afterPropertiesSet("><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Gemini",sidebar:{position:"left",display:"post",offset:12,offset_float:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!0,tabs:!0,motion:!0,duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="https://NextConner.github.io/joker/IoC-BirdView/"><title>IoC BirdView | Joker With Time Passing!</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">Joker With Time Passing!</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">Boy meets ambitions!</p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://NextConner.github.io/joker/IoC-BirdView/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Joker Zou"><meta itemprop="description" content><meta itemprop="image" content="/uploads/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Joker With Time Passing!"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">IoC BirdView</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-09T08:37:14+08:00">2020-05-09 </time></span><span class="post-updated">&nbsp; | &nbsp; 更新于 <time itemprop="dateUpdated" datetime="2020-05-11T23:33:43+08:00" content="2020-05-11">2020-05-11 </time></span><span class="post-meta-divider">|</span> <span class="page-pv"><i class="fa fa-file-o"></i> 阅读数 <span class="busuanzi-value" id="busuanzi_value_page_pv"></span></span><div class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">字数统计</span> <span class="post-count" title="字数统计">3.5k 字 </span><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长</span> <span title="阅读时长">13 分钟</span></div></div></header><div class="post-body" itemprop="articleBody"><h3 id="Ioc-概览"><a href="#Ioc-概览" class="headerlink" title="Ioc 概览"></a>Ioc 概览</h3><ul><li><h4 id="Bean-属性定制"><a href="#Bean-属性定制" class="headerlink" title="Bean 属性定制:"></a>Bean 属性定制:</h4><ul><li><p><strong>Spring</strong> 框架提供了一系列用于定制 <strong>Bean</strong> 的接口, 主要是 Bean 生命周期相关的回调方法（ <em>Lifecycle Callbacks</em> ）</p><hr><h4 id="生命周期相关的回调方法"><a href="#生命周期相关的回调方法" class="headerlink" title="生命周期相关的回调方法:"></a>生命周期相关的回调方法:</h4><ul><li><p>为了和Spring 对Bean 的管理相互影响，可以通过实现 <strong>InitializingBean</strong> 和 <strong>DisposableBean</strong> 接口，分别定义 Bean 的 afterPropertiesSet() 和 desyory() 方法，指定在Bean 属性设置完成和 Bean 销毁时的动作</p></li><li><p>在<strong>Spring</strong> 的内部，是通过接口 <strong>BeanPostProcessor</strong> 的实现类执行相关回调方法的，因此如果你想实现任何 <strong>Spring</strong> 没有提供的生命周期相关的动作，可以通过实现 <strong>BeanPostProcessor</strong> 接口来完成。</p></li><li><p><strong>初始化回调</strong></p><ul><li><p><em>afterPropertiesSet()</em> ：在Bean 所有<strong>必须的属性设置完成</strong>之后进行一些其他的初始化工作；</p></li><li><p>但是并不推荐继承 <strong>InitializingBean</strong> 接口来实现这一回调方法，因为会和Spring 的代码相耦合；建议通过 <strong>@PostConstruct</strong> 注解 ， 或者指定对象的初始化方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id = <span class="string">"exampleInitBean"</span> <span class="class"><span class="keyword">class</span> </span>= <span class="string">"examples.ExampleBaen"</span> init-method = <span class="string">"init"</span>&gt;</span><br><span class="line"><span class="comment">// xml 格式的配置元数据，指定 init-method 方法，作为初始化回调</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExcepleBane</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> init&#123;</span><br><span class="line">        <span class="comment">//初始化回调</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>生命周期结束回调</strong></p><ul><li><p><em>destory()</em> ： Bean 销毁方法</p></li><li><p>同样为了避免和 Spring 代码过度耦合，建议使用 <strong>@PreDestory</strong> 注解，或者在配置元数据中指定销毁方法，在<bean>中指定 <em>destory-method</em> 指向的方法作为 Bean 生命周期销毁时的回调。</bean></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id =<span class="string">"exampleInitBean"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"examples.ExampleBaen"</span> destory-method=<span class="string">"cleanup"</span>&gt;</span><br><span class="line"><span class="comment">//指定 destory-method 方法作为生命周期结束回调</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanup</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//销毁动作 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><a id="more"></a></li><li><p><strong>默认的Bean初始化和销毁回调方法</strong></p><ul><li><p>在<strong>约定俗成</strong>的情况下，人们通常会将初始化方法和销毁方法命名为类似 <em>init(),initialize(),dispose()</em>等，理想情况下这些命名方式是跨项目的规范，因此所有开发者都会遵守并保证它们的一致性(方法用途?)。</p></li><li><p>你可以配置Spring 容器在每一个Bean中查找 <strong>标准化</strong> 的初始化和销毁方法，这意味着，你可以在不进行任何配置(例如在配置元数据指定 init-method )的情况下，将一个命名为 <strong>init()</strong> 的方法作为 Bean 初始化方法使用，IOC容器会在Bean 创建之后调用它。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultBlogServie</span> <span class="keyword">implements</span> <span class="title">BolgService</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BlogDao blogDao;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBlogDao</span><span class="params">(BlogDao blogDao)</span></span>&#123;</span><br><span class="line">        <span class="comment">//属性注入</span></span><br><span class="line">        <span class="keyword">this</span>.blogDao = blogDao;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//会作为默认的初始化方法,检查属性设置之类的</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.blogDao == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The [blogDao] property must be set"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在元数据中这样定义:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">default-init-method</span>=<span class="string">"init"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 区别在于没有在 bean 定义本身去指定销毁方法，等于是使用了全部配置；也可以由此延伸出，如果定义了特定的销毁方法，将会覆盖全局设置 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>= <span class="string">"blogService"</span> <span class="attr">class</span> = <span class="string">"com.somthing.DefaultBlogService"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> = <span class="string">"blogDao"</span> <span class="attr">reg</span> = <span class="string">"blogDao"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong><beans></beans></strong>标签中的 <em>default-init-method</em> 会让 Spring 容器将下面所有Bean 中命名为 <em>init()</em> 的方法作为初始化方法，在适当的时候被<strong>反射调用</strong> (<em>default-destroy-method</em> 作用类似于 <em>default-init-method</em> )</p></li><li><p>在上面一点的前提下，也可以指定具体Bean 的初始化和销毁方法，覆盖全局设置</p></li><li><p><strong>Spring</strong> 容器会保证配置的初始化回调，会在Bean的所有依赖都被满足后立刻被调用。这意味着初始化回调(<strong>init 方法</strong>)是在原生Bean 引用上进行的，发生在 AOP 等动作之前。目标 Bean 对象完全创建出来之后，AOP拦截器调用链才会开始应用。</p></li><li><p>如果Bean 的定义和代理定义相分离，你甚至可以通过代理调用原生Bean 对象。（<strong>不理解</strong>）</p></li><li><p>因此，将拦截器放置在初始化方法中是不稳妥的，这样会将拦截器或者代理的代码和Bean的生命周期耦合起来，当你直接操作原生Bean 对象时，还会产生奇怪的语义。（<strong>不理解</strong>）</p></li></ul><hr></li><li><p><strong>结合Spring 生命周期机制</strong> :</p><ul><li><p><strong>Spring 2.5</strong>版本之后，可以有三种途径控制<strong>Bean</strong>生命周期:</p><ul><li><code>InitializingBean</code> 和 <code>DisposableBaen</code> 回调接口</li><li>定制 <code>init()</code> 和 <code>destory()</code>方法</li><li><p><code>@PostConstruct</code> 和 <code>@PreDestory</code> 注解</p><p>如果同时配置了使用了多个Bean生命周期控制的方法，当它们的方法名称不一样时，初始化(init)方法和销毁方法都会按照一定的顺序执行:</p><p>初始化生命周期方法执行顺序 ：</p><p>@PostConstruct 注解修饰的方法 &gt; InitializationBean.afterPropertiesSet()方法 &gt; 自定义的 init() 方法 <em>（参照前文）</em></p><p>生命周期结束方法执行顺序：</p><p>@PreDestory() 注解方法 &gt; DisposableBean.destory() &gt; 自定义的 destory() 方法</p><p>如果配置的生命周期方法名称一样，<strong>则配置的初始化方法和生命周期结束方法仅会执行一次</strong></p></li></ul></li></ul></li></ul><hr><ul><li><p><strong>启动停止回调</strong>:</p><ul><li><p><code>Lifecycle</code> 接口定义了任意对象所必须的满足生命周期的要求的方法(<em>启停方法和状态反馈等</em>)</p></li><li><p><strong>所有受到Spring 容器管理的对象都实现了Lifecycle接口</strong>，以<code>ApplicationContext</code> 为例，当它接收到启动或者停止信号（ <em>例如运行时接收到的 stop/restart 信号</em> ），<strong>它会级联所有定义在当前context 中的Lifecycle接口实现对象，进行同样的方法调用</strong>。这个动作会委派给 <code>LifecycleProcessor</code>接口实现:</p><p>LifecycleProcessor 接口定义如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LifecycleProcessor</span> <span class="keyword">extends</span> <span class="title">Lifecycle</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onClose</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul></li></ul><pre><code>   这里看不出它是如何进行级联其他定义在当前context中的对象的方法进行调用的，可以看看它的默认实现类:

   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultLifecycleProcessor</span> <span class="keyword">implements</span> <span class="title">LifecycleProcessor</span>,<span class="title">BeanFactoryAuare</span></span>&#123;</span><br><span class="line">	</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//这个方法有没有可能是进行Bean对象级联启动的方法？</span></span><br><span class="line">		startBeans(<span class="keyword">false</span>);</span><br><span class="line">		<span class="keyword">this</span>.running = <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//startBeans(Boolean)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startBeans</span><span class="params">(<span class="keyword">boolean</span> autoStartupOnly)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//从方法名看起来像是获取所有具备生命周期Bean对象的方法</span></span><br><span class="line">		Map&lt;String, Lifecycle&gt; lifecycleBeans = getLifecycleBeans();</span><br><span class="line">		Map&lt;Integer, LifecycleGroup&gt; phases = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">		lifecycleBeans.forEach((beanName, bean) -&gt; &#123;</span><br><span class="line">    <span class="comment">//设置的不自动重启，判断了Bean 的类型，以及当 SmartLifeCycle 类型的 Bean 是否需要根据容器的刷新而重启 </span></span><br><span class="line">			<span class="keyword">if</span> (!autoStartupOnly || (bean <span class="keyword">instanceof</span> SmartLifecycle &amp;&amp; ((SmartLifecycle) bean).isAutoStartup())) &#123;</span><br><span class="line">				<span class="keyword">int</span> phase = getPhase(bean);</span><br><span class="line">				LifecycleGroup group = phases.get(phase);</span><br><span class="line">				<span class="keyword">if</span> (group == <span class="keyword">null</span>) &#123;</span><br><span class="line">					group = <span class="keyword">new</span> LifecycleGroup(phase, <span class="keyword">this</span>.timeoutPerShutdownPhase, lifecycleBeans, autoStartupOnly);</span><br><span class="line">					phases.put(phase, group);</span><br><span class="line">				&#125;</span><br><span class="line">				group.add(beanName, bean);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		<span class="keyword">if</span> (!phases.isEmpty()) &#123;</span><br><span class="line">			List&lt;Integer&gt; keys = <span class="keyword">new</span> ArrayList&lt;&gt;(phases.keySet());</span><br><span class="line">			Collections.sort(keys);</span><br><span class="line">			<span class="keyword">for</span> (Integer key : keys) &#123;</span><br><span class="line">				phases.get(key).start();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//getLifecycleBeans</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Map&lt;String, Lifecycle&gt; <span class="title">getLifecycleBeans</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//获取了在DefaultLifecycleProcessor 注入的 beanFactory 对象，将ConfigurableListableBeanFactory的子类强转</span></span><br><span class="line">		ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">		Map&lt;String, Lifecycle&gt; beans = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line"><span class="comment">//获取指定类型的Bean的名称，这里获取了所有具备生命周期方法实现的Bean对象的名称</span></span><br><span class="line">		String[] beanNames = beanFactory.getBeanNamesForType(Lifecycle.class, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">		<span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line"><span class="comment">//获取真正的bean对象的名称，剥离多余的前缀信息</span></span><br><span class="line">			String beanNameToRegister = BeanFactoryUtils.transformedBeanName(beanName);</span><br><span class="line">			<span class="keyword">boolean</span> isFactoryBean = beanFactory.isFactoryBean(beanNameToRegister);</span><br><span class="line">			String beanNameToCheck = (isFactoryBean ? BeanFactory.FACTORY_BEAN_PREFIX + beanName : beanName);</span><br><span class="line"><span class="comment">//判断是否是单例Bean对象，是否是实现了FactoryBean等</span></span><br><span class="line">			<span class="keyword">if</span> ((beanFactory.containsSingleton(beanNameToRegister) &amp;&amp;</span><br><span class="line">					(!isFactoryBean || matchesBeanType(Lifecycle.class, beanNameToCheck, beanFactory))) ||</span><br><span class="line">					matchesBeanType(SmartLifecycle.class, beanNameToCheck, beanFactory)) &#123;</span><br><span class="line">   <span class="comment">//根据名称获取Bean对象</span></span><br><span class="line">				Object bean = beanFactory.getBean(beanNameToCheck);</span><br><span class="line">				<span class="keyword">if</span> (bean != <span class="keyword">this</span> &amp;&amp; bean <span class="keyword">instanceof</span> Lifecycle) &#123;</span><br><span class="line">       <span class="comment">//保存所有获取到的符合条件的Bean对象</span></span><br><span class="line">					beans.put(beanNameToRegister, (Lifecycle) bean);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> beans;</span><br><span class="line">		<span class="comment">//（这个流程很类似于读取配置元数据然后保存Bean信息）</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


    到这里可以比较明了地看到，它是如何级联所有继承了**Lifecycle** 接口Bean进行生命周期方法触发的

- 可以注意到 **LifecycleProcessor** 也是继承了 **Lifecycle** 接口的， 并且新增了额外的 *onRefresh()  和  onClose()* 方法响应容器的刷新和关闭

  - 注意 **Lifecycle** 接口只是简单的进行显性**启动，停止**通知的接口，再容器刷新的时候它并不会实现**自动刷新**。因此如果需要在Bean启动时进行更加精细的控制，考虑实现 **SmartLifecycle** 接口代替。

    同时，需要注意**停止**通知并不保证会发生在销毁动作之前。在常规的停止操作中，所有实现了 **Lifecycle** 的Bean 对象会在通用销毁回调方法执行之间收到**停止**信号。然而，**在容器生命周期活动范围内的热更新或者试图放弃更新的操作，都会导致Baen仅仅调用 destory() 方法进行销毁**



- 依赖对象之间的启动和停止顺序可以很重要的，如果两个对象之间存在依赖关系，那么毫无疑问，依赖方会在它依赖的对象**启动之后**启动，且会在它的依赖方**停止之前**停止。然而，有时候它们彼此之间的直接依赖关系是不明确的，你可能只知道某些指定类型的Bean对象需要在另一些指定类型的Bean对象之前启动。在这种情况下，接口 **SmartLifecycle** 给定了另一个选项 -- `getPhase()` 方法 -- 返回 Bean 对象**启动阶段**类似的指标

  - <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SmartLifecycle</span> <span class="keyword">extends</span> <span class="title">Lifecycle</span> ,<span class="title">Phased</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isAutoStartup</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">(Runnable callback)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

  - 容器当启动时，启动阶段优先级最低的对象最先启动。容器停止时，按照启动阶段优先级倒序进行停止操作。因此，实现了 **SmartLifercycle** 接口并且 `getPhase()` 接口返回 Integer.MAX_VALUE 的对象将会第一个启动且最后一个停止。同时也表明了，任意没有实现 **SmartLifecycle** 接口的Bean对象，返回的启动阶段值肯定是0 -- 即最后一个启动，第一个停止。**因此，负值的启动阶段优先级，表明当前对象会在标准组件启动之后启动，并在它们停止之前停止，同样适用于正值的启动优先级值。**

  - 接口 **SmartLifecycle** 定义的 stop 方法接收一个回调动作。任意实现该接口的类都需要在`shutdown()`方法调用完成之后调用 `run()`回调方法。//TODO (没看懂)

  - 像之前提到的那样，`LifecycleProcessor` 接口定义了响应上下文 **刷新和关闭的** 的回调方法。后者(*上下文关闭*)就像是明确调用了容器的`stop()`方法。

------

- **ApplicationContextAware 和 BeanNameAware 接口**

  - 当 `ApplicationContext` 容器创建了一个实现了`org.springframework.context.ApplicationContextAware` 接口的对象实例，该实例将会持有指向该容器的引用，接口代码如下:

  - <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationContextAware</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

  - 因此，这些 **bean** 对象可以通过代码区操作创建它们的容器对象，或者通过将接口前强转成该容器的子类进行使用。其中一个用途就是借此检索其它的 Bean 对象。但是建议不要这么做，因为这样会将自己的代码和Spring 容器耦合得比较紧密，而且违反了 **IoC** 风格。

  - 在 *Spring 2.5* 版本，自动注入是另一种可以获得 ApplicationContext 容器引用的方法。传统的**构造注入**和**类型注入**模式可以分别为构造函数和**setter**方法提供容器依赖作为参数使用。开启**基于注解的依赖注入模式**，通过 `@Autowired` 注解可以更加灵活地实现将 ApplicationContext 作为字段，构造参数或者方法参数等进行依赖注入。

  - 当 **ApplicationContext** 容器创建一个实现了 **org.apringframework.baens.factory.BeanNameAware** 接口的类，该类会持有自身作为 **Bean被定义的名称**的引用。如下所示:

  - <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanNameAware</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setBeanName</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

  - **这个回调方法会在普通Bean对象的特性设置完成之后，Bean初始化方法调用之前调用，例如在 InitialicationBean ，afterPropertiesSet 或者自定义的初始化方法之前。**

  - 其它注入相关接口:

     - `ApplicationContextAware` ：会注入 ApplicationContext 的依赖
     - `ApplicationEventPublisherAware` ： 注入可封闭的 ApplicationContext 容器的事件发布者依赖
     - `BeanClassLoaderAware` : 注入加载当前bean 的类加载器
     - `BeanFactoryAware` : 注入定义的 BeanFactory  
     - `BeanNameAware` : 注入声明的Bean 的名称引用
     - `ResourceLoaderAware` : 定义的加载外部配置文件的加载器
     - `ServletContextAware` : 当前容器运行的 **ServletContext** ，仅在web 类型容器上下文生效

  - **需要注意，实现这些接口去访问Spring 中的对象，会使代码耦合，因此建议仅在必要的时候使用，例如自己定义的作为基础Bean 对象使用的情况下。**
</code></pre><ul><li><p><strong>小结</strong></p><ul><li>为 <strong>Bean</strong> 对象指定初始化和销毁等生命周期方法，可以在Bean 定义上配置<strong>init-method</strong> 和 <strong>destory-method</strong> ，容器会根据其中配置的方法名去查找该对象的初始化和销毁方法在合适的时候进行调用</li><li>也可以在 <strong>Beans</strong> 标签中为其内所有的 <strong>Bean</strong> 对象指定默认初始化和销毁的生命周期方法，注意这个配置是可以被 Bean 自身的配置覆盖的。</li><li>在 <strong>Spring 2.5</strong> 版本之后可以通过 @PostConstruct 注解，实现 InitializationBean.afterPropertiesSet()方法 ， 自定义的 init() 方法 控制 Bean 初始化生命周期，通过 @PreDestory() 注解， 实现 DisposableBean.destory() ， 自定义的 destory() 方法控制Bean 的销毁生命周期 ， 它们的执行顺序也正如描述所示，但是需要注意 : <strong>如果同时实现了三个不同名称的生命周期方法(多个初始化或销毁)，则三个方法都会执行；如果定义了相同名称的生命周期方法，则按照优先级顺序，仅会执行其中一个。</strong></li><li>所有受 Spring 容器管理的对象都会继承 <code>Lifecycle</code> 接口。然后当 <code>ApplicationContext</code>自身接收到了启停信号，它会级联所有实现了<code>Lifecycle</code> 接口的对象，并调用这些对象的启停生命周期方法。</li></ul></li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/笔记/" rel="tag"># 笔记</a> <a href="/tags/Spring/" rel="tag"># Spring</a> <a href="/tags/框架/" rel="tag"># 框架</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/joker/一学一记：代码时间-空间复杂度/" rel="next" title="一学一记：代码时间/空间复杂度"><i class="fa fa-chevron-left"></i> 一学一记：代码时间/空间复杂度</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/joker/一学一记：数组结构/" rel="prev" title="一学一记：数组结构">一学一记：数组结构 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"></div></div></div><div class="comments" id="comments"></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview">站点概览</li></ul><section class="site-overview sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/uploads/avatar.jpg" alt="Joker Zou"><p class="site-author-name" itemprop="name">Joker Zou</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">17</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">4</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">20</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="links-of-author motion-element"></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#Ioc-概览"><span class="nav-number">1.</span> <span class="nav-text">Ioc 概览</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Bean-属性定制"><span class="nav-number">1.1.</span> <span class="nav-text">Bean 属性定制:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#生命周期相关的回调方法"><span class="nav-number">1.2.</span> <span class="nav-text">生命周期相关的回调方法:</span></a></li></ol></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="copyright">&copy; <span itemprop="copyrightYear">2020</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Joker Zou</span></div><div class="powered-by">由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动</div><div class="theme-info">主题 - <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a></div><div class="busuanzi-count"><script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="site-uv">访客数 <span class="busuanzi-value" id="busuanzi_value_site_uv"></span> 只 </span><span class="site-pv"><i class="fa fa-eye"></i> 总访问量 <span class="busuanzi-value" id="busuanzi_value_site_pv"></span> 回</span></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script><script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script><script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script></body></html>