<!DOCTYPE html><html class="theme-next gemini use-motion" lang="zh-Hans,US,JP,default"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css"><meta name="keywords" content="数据结构,链表,实践,"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2"><meta name="description" content="链表相关实操概述在链表的操作中，理解链表指针的概念很重要；C语言的指针代表的意思是对象的内存地址，在Java对应的概念则是引用；将对象赋值给变量 ，实际是将对象的内存地址赋值给了变量，用来定位对象在内存中的位置。为了更深入地理解这些概念和链表结构，通过：反转单链表，合并有序单链表，检测链表环，删除链表倒数第N个节点这四个实践场景来加深印象。反转单链表给定链表 a -&amp;gt; b -&amp;gt; c -"><meta name="keywords" content="数据结构,链表,实践"><meta property="og:type" content="article"><meta property="og:title" content="一学一记:链表相关实操"><meta property="og:url" content="https://NextConner.github.io/joker/一学一记-链表相关实操/index.html"><meta property="og:site_name" content="Joker With Time Passing!"><meta property="og:description" content="链表相关实操概述在链表的操作中，理解链表指针的概念很重要；C语言的指针代表的意思是对象的内存地址，在Java对应的概念则是引用；将对象赋值给变量 ，实际是将对象的内存地址赋值给了变量，用来定位对象在内存中的位置。为了更深入地理解这些概念和链表结构，通过：反转单链表，合并有序单链表，检测链表环，删除链表倒数第N个节点这四个实践场景来加深印象。反转单链表给定链表 a -&amp;gt; b -&amp;gt; c -"><meta property="og:locale" content="zh-Hans"><meta property="og:updated_time" content="2020-05-15T00:35:59.740Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="一学一记:链表相关实操"><meta name="twitter:description" content="链表相关实操概述在链表的操作中，理解链表指针的概念很重要；C语言的指针代表的意思是对象的内存地址，在Java对应的概念则是引用；将对象赋值给变量 ，实际是将对象的内存地址赋值给了变量，用来定位对象在内存中的位置。为了更深入地理解这些概念和链表结构，通过：反转单链表，合并有序单链表，检测链表环，删除链表倒数第N个节点这四个实践场景来加深印象。反转单链表给定链表 a -&amp;gt; b -&amp;gt; c -"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Gemini",sidebar:{position:"left",display:"post",offset:12,offset_float:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!0,tabs:!0,motion:!0,duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="https://NextConner.github.io/joker/一学一记-链表相关实操/"><title>一学一记:链表相关实操 | Joker With Time Passing!</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">Joker With Time Passing!</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">Boy meets ambitions!</p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://NextConner.github.io/joker/一学一记-链表相关实操/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Joker Zou"><meta itemprop="description" content><meta itemprop="image" content="/uploads/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Joker With Time Passing!"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">一学一记:链表相关实操</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-13T06:54:02+08:00">2020-05-13 06:54:02 </time></span><span class="post-updated">&nbsp; | &nbsp; 更新于 <time itemprop="dateUpdated" datetime="2020-05-15T08:35:59+08:00" content="2020-05-15 08:35:59">2020-05-15 08:35:59 </time></span><span class="post-meta-divider">|</span> <span class="page-pv"><i class="fa fa-file-o"></i> 阅读数 <span class="busuanzi-value" id="busuanzi_value_page_pv"></span></span><div class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">字数统计</span> <span class="post-count" title="字数统计">2.3k 字 </span><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长</span> <span title="阅读时长">9 分钟</span></div></div></header><div class="post-body" itemprop="articleBody"><h2 id="链表相关实操"><a href="#链表相关实操" class="headerlink" title="链表相关实操"></a>链表相关实操</h2><hr><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li>在链表的操作中，理解链表指针的概念很重要；C语言的指针代表的意思是对象的<strong>内存地址</strong>，在Java对应的概念则是<strong>引用</strong>；将对象赋值给变量 ，实际是将对象的<strong>内存地址</strong>赋值给了变量，用来定位对象在内存中的位置。</li><li>为了更深入地理解这些概念和链表结构，通过：<strong>反转单链表，合并有序单链表，检测链表环，删除链表倒数第N个节点</strong>这四个实践场景来加深印象。</li></ul><h3 id="反转单链表"><a href="#反转单链表" class="headerlink" title="反转单链表"></a>反转单链表</h3><ul><li><p>给定链表 a -&gt; b -&gt; c -&gt; d-&gt; e ，反转成 e -&gt; d-&gt; c-&gt; b-&gt; -&gt;a ,并返回头节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    Object value = <span class="keyword">null</span>;</span><br><span class="line">    Node next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//反转单链表</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseLinkList</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    Node first = <span class="keyword">new</span> Node(<span class="keyword">null</span>);</span><br><span class="line">    first.next = head;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        Node move = head.next;</span><br><span class="line">        Node moveNext = head.next.next;</span><br><span class="line">        <span class="comment">//修改指针引用</span></span><br><span class="line">        head.next = moveNext;</span><br><span class="line">        move.next = first.next;<span class="comment">//链接到第一个非空节点</span></span><br><span class="line">        first.next = move; <span class="comment">// move 成为第一个非空节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//输出</span></span><br><span class="line">    <span class="keyword">while</span>(first.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        printf(first.next.value + <span class="string">" ---&gt; "</span>)</span><br><span class="line">        first = first.next;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(<span class="string">"null"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>最开始想到的思路是：</p><ul><li><p>先记录尾节点，将头节点一次移动一个位置</p></li><li><p>当前头节点移动至链表尾部时，再次循环将新的头节点移动到链表尾部</p><a id="more"></a></li></ul></li><li><p>这个思路导致我陷入怎么控制外层循环的问题中，为了在合适的时候结束循环，将事先记录的尾节点和当前头节点对比，代码逻辑混乱没有实现出来</p></li><li><p>现在的这个思路，其实就是通过增加带头节点控制整条链表的第一个节点的位置；每次操作都看作是将<strong>第二个</strong>节点插入到都头节点和第一个节点之间，当第一个节点指向空，说明链表已经反转完成</p></li></ul><hr><h3 id="删除链表倒数第N个节点"><a href="#删除链表倒数第N个节点" class="headerlink" title="删除链表倒数第N个节点"></a>删除链表倒数第N个节点</h3><ul><li><p>因为链表是无法通过索引定位元素的，所以删除倒数第N个节点需要再遍历的时候记录当前节点的索引位置，尝试实现一下</p><ul><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//删除链表倒数第N个节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">delNIndexNode</span><span class="params">(Node head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 1. 假设链表长度为k, 需要进行 k-n 次遍历才能到达 n 节点位置</span></span><br><span class="line"><span class="comment">    * 2. 但是此时也并不知道那是第 n 个节点</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    Node first = head;</span><br><span class="line">    Node snode = head;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        head = head.next; <span class="comment">// n 次执行</span></span><br><span class="line">        i++;              <span class="comment">// n 次执行</span></span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123; <span class="comment">// n 次</span></span><br><span class="line">            <span class="keyword">int</span> k = i-n;  		</span><br><span class="line">            <span class="keyword">while</span>(first.next !=<span class="keyword">null</span>)&#123; <span class="comment">//k 次</span></span><br><span class="line">                first=first.next;   <span class="comment">// k 次</span></span><br><span class="line">                k--;			</span><br><span class="line">                <span class="keyword">if</span>(k==<span class="number">0</span>)&#123;</span><br><span class="line">                    Node del = first.next;</span><br><span class="line">                    Node next = first.next.next;</span><br><span class="line">                    <span class="comment">//删除节点</span></span><br><span class="line">                    first.next = next;</span><br><span class="line">                    del.next=<span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (snode!= <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.print(snode.value + <span class="string">" ---&gt; "</span>);</span><br><span class="line">        snode = snode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.print(<span class="string">"null"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>最开始的思路是反转链表，然后 n – 去删除节点，但是为了维持链表本身的顺序，还得再次反转，觉得应该不是好办法</p></li><li><p>不定长的链表，要获取倒数第N个，不仅得<strong>到达</strong>倒数第N个位置；还得<strong>知道</strong>这是倒数第N个节点；</p></li><li><p>因为没想到其他办法，还是先遍历获得链表长度 k ,正序的删除位置就是 i = k - n; 再 i – 进行正序遍历删除；</p></li><li><p><strong>觉得</strong>这个应该也不是最优解，先遍历让长度已知再去正序遍历感觉解法太普通</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//再次尝试简化代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">delNNodeNew</span><span class="params">(Node head,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    Node first = head;</span><br><span class="line">    Node snode = head;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="comment">//将 n 减少到负数</span></span><br><span class="line">        <span class="keyword">if</span>(head.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            n--;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//得出正序的位置</span></span><br><span class="line">            <span class="keyword">if</span>(n &lt;<span class="number">0</span>)&#123;</span><br><span class="line">                n=-<span class="number">1</span>*n;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(n!=<span class="number">0</span>)&#123;</span><br><span class="line">                first = first.next;</span><br><span class="line">                n--;</span><br><span class="line">            &#125;</span><br><span class="line">            Node del = first.next;</span><br><span class="line">            Node next = first.next.next;</span><br><span class="line">            <span class="comment">//删除节点</span></span><br><span class="line">            first.next = next;</span><br><span class="line">            del.next=<span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(snode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>相比之前的那种实现，少了 i 和 k 的计数赋值，但还是得经历一次遍历才能知道正序的位置，也不是最优解，参考了一下正确答案</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">deleteLastN</span><span class="params">(Node head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">1</span> || head == <span class="keyword">null</span>) &#123;</span><br><span class="line">    	<span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    Node guard = <span class="keyword">new</span> Node(<span class="string">'/'</span>);</span><br><span class="line">    guard.next = head;</span><br><span class="line"></span><br><span class="line">    Node slow = guard;</span><br><span class="line">    Node fast = guard;</span><br><span class="line">	<span class="comment">//先将快指针移动k-1次</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    	<span class="keyword">if</span>(fast != <span class="keyword">null</span>) &#123;</span><br><span class="line">    		fast = fast.next;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//快慢指针一起前进，当快指针到达队尾，慢指针所在位置就是的下一个节点就是需要删除的节点</span></span><br><span class="line">    <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">    	slow = slow.next;</span><br><span class="line">    	fast = fast.next;</span><br><span class="line">    &#125;</span><br><span class="line">    slow.next = slow.next.next;</span><br><span class="line">    <span class="keyword">return</span> guard.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>一个指针遍历定位不到n的位置，所以需要将问题转换成用相对距离确定n的位置，结束条件就是距离链表尾部n长的节点就是第n个节点</strong></p></li><li><p>自己的思路还是没有开阔起来，偏向于常规思考模式，值得警惕</p></li></ul><hr><h3 id="合并有序单链表"><a href="#合并有序单链表" class="headerlink" title="合并有序单链表"></a>合并有序单链表</h3><ul><li><p>合并有序单链表要确保合并后的单链表也是有序的，以<strong>A链表</strong>为基准，用<strong>B链表</strong>去合并，需要小心每次插入一个B节点到A链表中，不能丢失B链表的余下节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    E value = <span class="keyword">null</span>;</span><br><span class="line">    Node next;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">compare</span><span class="params">(Node&lt;E&gt; that)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value.compareTo(that.value)&gt;=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//合并有序单链表</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeLink</span><span class="params">(Node&lt;Integer&gt; headA,Node&lt;Integer&gt; headB)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    Node&lt;Integer&gt; firstA = <span class="keyword">new</span> Node&lt;&gt;(<span class="keyword">null</span>);</span><br><span class="line">    firstA.next=headA;</span><br><span class="line">    Node&lt;Integer&gt; firstB = <span class="keyword">new</span> Node&lt;&gt;(<span class="keyword">null</span>);</span><br><span class="line">    firstB.next=headB;</span><br><span class="line">    Node&lt;Integer&gt; temp = headB;</span><br><span class="line">    Node&lt;Integer&gt; tb = headA;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(temp!=<span class="keyword">null</span>)&#123;</span><br><span class="line">		<span class="comment">//需要判断A链是否到了尾部</span></span><br><span class="line">        <span class="keyword">if</span>(tb.next !=<span class="keyword">null</span> &amp;&amp; tb.next.compare(temp))&#123; </span><br><span class="line">            <span class="comment">// A 的节点大于 B 头节点，B需要插入到头部</span></span><br><span class="line">            <span class="comment">//保持B链不断</span></span><br><span class="line">            firstB.next = temp.next;</span><br><span class="line">            <span class="comment">//B 插入A 链</span></span><br><span class="line">            temp.next=tb.next;</span><br><span class="line">            tb.next=temp;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// A 节点 &lt; B</span></span><br><span class="line">            <span class="keyword">if</span>(tb.next==<span class="keyword">null</span> &amp;&amp; !tb.compare(temp))&#123;</span><br><span class="line">                tb.next=temp;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            tb = tb.next;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = firstB.next;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(firstA);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>确定跳出循环的条件是一条链表中的节点已经遍历完毕，最开始的是实现在第26行少了<strong>A链表到达尾部</strong>的判断，导致B链表的最后一个数被跳过</p></li><li><p>这里也需要处理极端的情况，如果A链遍历一次之后，发现A链的尾节点大于B链的头节点，直接将整条B链插入到A链表中即可</p></li></ul><hr><h3 id="检测链表环"><a href="#检测链表环" class="headerlink" title="检测链表环"></a>检测链表环</h3><ul><li><p>这个因为我之前了解了思路是用<strong>快慢指针</strong>实现的，所以等于是看到了答案</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkaLinkCycle</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    Node slow = head;</span><br><span class="line">    Node fast = head.next;</span><br><span class="line">    <span class="comment">//如果链表存在环，快指针就会一直绕圈，直到在【某一圈】追上慢指针</span></span><br><span class="line">    <span class="keyword">while</span>(fast.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(slow.next.equals(fast.next))&#123;</span><br><span class="line">            System.out.println(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            slow=slow.next;</span><br><span class="line">            fast=fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Node a = <span class="keyword">new</span> Node(<span class="number">1</span>);</span><br><span class="line">    Node b = <span class="keyword">new</span> Node(<span class="number">3</span>);</span><br><span class="line">    Node c = <span class="keyword">new</span> Node(<span class="number">5</span>);</span><br><span class="line">    Node d = <span class="keyword">new</span> Node(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">    Node e = <span class="keyword">new</span> Node(<span class="number">2</span>);</span><br><span class="line">    Node f = <span class="keyword">new</span> Node(<span class="number">4</span>);</span><br><span class="line">    Node h = <span class="keyword">new</span> Node(<span class="number">6</span>);</span><br><span class="line">    Node i = <span class="keyword">new</span> Node(<span class="number">8</span>);</span><br><span class="line">    a.next = b;</span><br><span class="line">    b.next = c;</span><br><span class="line">    c.next = d;</span><br><span class="line">    d.next=e;</span><br><span class="line">    e.next = f;</span><br><span class="line">    f.next=h;</span><br><span class="line">    h.next=i;</span><br><span class="line">    i.next=a;</span><br><span class="line">    checkLinkCycle(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>这个问题没有太多的思考过程，因为提前知道了解法就是快慢指针</p></li><li><p>关于快慢指针的<strong>步长</strong>：</p><ul><li>在环形链表中，慢指针始终以 1 的速度前进</li><li>快指针以 N 倍于慢指针的速度前进</li><li>快指针<strong>最少</strong>前进了多少步才会恰好与慢指针相遇 ?</li><li>我用上面的代码做了测试，将快指针分别取 2 ，4，6，8倍步长，计数循环的次数分别是:7 , 5，3，1。结论就是<strong>快慢指针步长差刚好是一倍链表长度</strong>快指针可以 <strong>1步</strong> 追上慢指针；</li><li>那么问题来了：<strong>链表多长?</strong> 不知道，链表都是引用关联起来的，长度属性对于它的应用场景不那么重要。因此快指针取 <strong>2倍</strong> 慢指针的步长，可以保证它一定会追上慢指针</li></ul></li></ul><hr><h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h3><ul><li>链表的操作中，需要注意的就是<strong>指针丢失</strong>，在改变节点指针的时候，a-b-c,将d插入到b，c之间； <strong>操作顺序一定是先确保c节点不会丢失，先将d指向c，再将b指向d，结果就是 a-b-d-c </strong>；</li><li>如果是像合并有序单链表这样的操作，就得注意维持<strong>被移除了节点的链表</strong>的引用不丢失:<ul><li>A链: a-b-c-d ; B链: e-f-g-h</li><li>e 插入到 a，b之间 ：<ul><li>e.next = a.next ; a.next = e ; 这种操作就是错的，因为 e.next = f , 直接改变 e.next 的指向会导致 B链丢失</li></ul></li><li>先添加指向B链头部的 firstB -&gt; e;将 e 插入 a，b的操作顺序就是:<ul><li>firstB.next = e.next ; //保证B链的引用还在</li><li>e.next = a.next ; a.next = e</li></ul></li></ul></li><li>链表的操作中稍微没有兼容到边界情况的话，例如空链表，单节点链表等，换个例子就跑不通了</li></ul></li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/数据结构/" rel="tag"># 数据结构</a> <a href="/tags/链表/" rel="tag"># 链表</a> <a href="/tags/实践/" rel="tag"># 实践</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/joker/一学一记-链表/" rel="next" title="一学一记:链表"><i class="fa fa-chevron-left"></i> 一学一记:链表</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/joker/一学一记-栈/" rel="prev" title="一学一记:栈">一学一记:栈 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"></div></div></div><div class="comments" id="comments"></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview">站点概览</li></ul><section class="site-overview sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/uploads/avatar.jpg" alt="Joker Zou"><p class="site-author-name" itemprop="name">Joker Zou</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">22</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">4</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">27</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="links-of-author motion-element"></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#链表相关实操"><span class="nav-number">1.</span> <span class="nav-text">链表相关实操</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概述"><span class="nav-number">1.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#反转单链表"><span class="nav-number">1.2.</span> <span class="nav-text">反转单链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#删除链表倒数第N个节点"><span class="nav-number">1.3.</span> <span class="nav-text">删除链表倒数第N个节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#合并有序单链表"><span class="nav-number">1.4.</span> <span class="nav-text">合并有序单链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#检测链表环"><span class="nav-number">1.5.</span> <span class="nav-text">检测链表环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小结："><span class="nav-number">1.6.</span> <span class="nav-text">小结：</span></a></li></ol></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="copyright">&copy; <span itemprop="copyrightYear">2020</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Joker Zou</span></div><div class="powered-by">由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动</div><div class="theme-info">主题 - <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a></div><div class="busuanzi-count"><script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="site-uv">访客数 <span class="busuanzi-value" id="busuanzi_value_site_uv"></span> 只 </span><span class="site-pv"><i class="fa fa-eye"></i> 总访问量 <span class="busuanzi-value" id="busuanzi_value_site_pv"></span> 回</span></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script><script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script><script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script></body></html>