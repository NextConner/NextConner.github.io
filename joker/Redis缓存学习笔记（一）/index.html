<!DOCTYPE html><html class="theme-next gemini use-motion" lang="zh-Hans,US,JP,default"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css"><meta name="keywords" content="JAVA,NOSQL,缓存,"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2"><meta name="description" content="Redis 学习笔记(一)简述.Redis (Remote Dictionary Server) ，是一个基于内存的高性能Key-Value数据库；支持多种丰富的数据类型，而且由于纯内存访问和优秀的单线程架构，所以具备很高的响应性。支持主从模式，在单机多机环境下分别支持哨兵和集群搭建高可用环境。Redis 优点：访问速度快： Redis 将数据保存在内存中，存取速度比较可观；并且可以定期通过异步操"><meta name="keywords" content="JAVA,NOSQL,缓存"><meta property="og:type" content="article"><meta property="og:title" content="Redis缓存学习笔记（一）"><meta property="og:url" content="https://NextConner.github.io/joker/Redis缓存学习笔记（一）/index.html"><meta property="og:site_name" content="Joker With Time Passing!"><meta property="og:description" content="Redis 学习笔记(一)简述.Redis (Remote Dictionary Server) ，是一个基于内存的高性能Key-Value数据库；支持多种丰富的数据类型，而且由于纯内存访问和优秀的单线程架构，所以具备很高的响应性。支持主从模式，在单机多机环境下分别支持哨兵和集群搭建高可用环境。Redis 优点：访问速度快： Redis 将数据保存在内存中，存取速度比较可观；并且可以定期通过异步操"><meta property="og:locale" content="zh-Hans"><meta property="og:updated_time" content="2019-07-31T23:36:05.073Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Redis缓存学习笔记（一）"><meta name="twitter:description" content="Redis 学习笔记(一)简述.Redis (Remote Dictionary Server) ，是一个基于内存的高性能Key-Value数据库；支持多种丰富的数据类型，而且由于纯内存访问和优秀的单线程架构，所以具备很高的响应性。支持主从模式，在单机多机环境下分别支持哨兵和集群搭建高可用环境。Redis 优点：访问速度快： Redis 将数据保存在内存中，存取速度比较可观；并且可以定期通过异步操"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Gemini",sidebar:{position:"left",display:"post",offset:12,offset_float:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!0,tabs:!0,motion:!0,duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="https://NextConner.github.io/joker/Redis缓存学习笔记（一）/"><title>Redis缓存学习笔记（一） | Joker With Time Passing!</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">Joker With Time Passing!</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">Boy meets ambitions!</p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://NextConner.github.io/joker/Redis缓存学习笔记（一）/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Joker Zou"><meta itemprop="description" content><meta itemprop="image" content="/uploads/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Joker With Time Passing!"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Redis缓存学习笔记（一）</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-23T22:13:13+08:00">2019-07-23 </time></span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/笔记/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="Redis-学习笔记-一"><a href="#Redis-学习笔记-一" class="headerlink" title="Redis 学习笔记(一)"></a>Redis 学习笔记(一)</h2><hr><h3 id="简述"><a href="#简述" class="headerlink" title="简述."></a>简述.</h3><ul><li><strong>Redis</strong> (Remote Dictionary Server) ，是一个基于<strong>内存</strong>的高性能Key-Value数据库；支持多种丰富的数据类型，而且由于纯内存访问和优秀的单线程架构，所以具备很高的响应性。支持<strong>主从模式</strong>，在单机多机环境下分别支持<strong>哨兵</strong>和<strong>集群</strong>搭建高可用环境。</li></ul><hr><h3 id="Redis-优点："><a href="#Redis-优点：" class="headerlink" title="Redis  优点："></a>Redis 优点：</h3><ul><li><p><strong>访问速度快：</strong> Redis 将数据保存在内存中，存取速度比较可观；并且可以定期通过异步操作将数据库数据持久化到本地磁盘，作为灾难恢复和数据转移的准备。</p></li><li><p><strong>支持丰富的数据结构：</strong> Redis 大受欢迎的原因还在于它提供了丰富的数据结构:string,hash,list,set,zset,Pub/Sub,Geo等，可以很大程度上直接满足业务场景的需求。</p></li><li><p><strong>丰富的特性：</strong></p><ul><li><p>支持简单的发布订阅</p></li><li><p>Key过期策略：在缓存一致性问题中可以提供帮助</p></li><li><p>事务特性</p></li><li><p>支持多DB:16个，从0开始</p></li><li><p>原子计数</p></li><li><p>Session 共享</p></li><li><p>分布式锁</p><p>…</p></li></ul></li><li><p><strong>持久化存储：</strong> RDB，AOF</p></li></ul><h3 id="Redsi缺点"><a href="#Redsi缺点" class="headerlink" title="Redsi缺点"></a>Redsi缺点</h3><ul><li>内存存储所以受到机器本身的内存限制，需要制定数据的定期清除策略等</li><li><strong>RDB</strong>会占用主机CPU，导致Redis 卡顿等。</li><li>修改配置文件，重启服务，预热大量数据时间比较久，期间Redis 不能提供服务</li></ul><h3 id="Redis-数据结构："><a href="#Redis-数据结构：" class="headerlink" title="Redis 数据结构："></a>Redis 数据结构：</h3><ul><li>概述: Redis 提供了 string(字符串)，hash，list(列表)，set(集合)，zset(顺序集合)这些基本数据类型，以及在此基础上构建的复杂类型。</li><li><strong>string</strong> :<ul><li>字符串是 Redis 最基础的数据结构，在Redis 中，key 都是字符串类型，其他几种类型都是在字符串的基础上构建的。虽然是字符串类型，但实际的值可以是多种形式的字符串：json,xml,数字，二进制等，最大值限制是512M.</li><li><code>set key value [过期时间] [毫秒数] [NX|XX]</code> : 因为在单机环境下，redis 的分布式锁可以通过它实现。<ul><li>set 命令带上过期时间参数和NX ，表示设置一个具有时限的独占锁。</li><li>过期时间防止忘记释放锁导致后来者无法获取锁；NX表示key不存在才会创建，也就是只有一个锁。</li><li>这条命令的简化版本是 <code>setnx,setex</code>，可以保证原子性的形况下才能一起使用实现分布式锁。</li></ul></li><li><code>mget/mset</code> : 批量操作命令<ul><li>设想一个执行n次get命令的场景：每一次get都需要发送一次请求，等待一次返回(单线程模型)，效率不高</li><li>mget 命令只会发送一次请求，然后等待服务端一次执行n次get之后将结果全部返回，节省了<strong>网络IO</strong>时间</li><li>需要注意批量操作的数据量限制，如果超过带宽或者其他资源瓶颈，可能会出现网络拥塞等问题。</li></ul></li><li><code>incr/incrby/decr/decrby key [num]</code> : 对于内容是数字类型的key进行增减和指定参数的增减<ul><li>当 value 值是数字类型的时候，可以使用这些命令进行增减</li><li>非数字类型value会报错</li><li>不存在的key会被创建并增加，这一点需要注意，它并不会因为key不存在而返回null</li></ul></li><li><strong>string类型内部编码</strong>：根据实际存储的<strong>值类型和长度</strong>使用不同的内部编码实现<ul><li>int : 8字节的长整型</li><li>embstr : 小于等于39个字节的字符串</li><li>raw : 大于 39 字节的字符串</li></ul></li></ul></li><li><strong>hash</strong> :<ul><li>和其他数据结构可能有点不一样，Redis 本身是key-value存储，hash结构的键又是一个key-value类型，类似于：user:1:name -tom,适合用来表示对象类型。哈希的映射关系叫做 field-value，value 不是指键对应得值，而是field对应的值。</li><li><code>hget/hset/hdel/ key field value</code> ： hset user:name tom<ul><li>基本的命令，hdel 可以删除多个dield ： hdel key [f1,f2,f3…]</li></ul></li><li><code>hmget/hmset/hkeys/hvals</code> : 批量设置/获取/获取键/获取值等命令</li></ul></li><li><strong>list</strong> :<ul><li>列表，<strong>有序存储多个字符串</strong>，是个<strong>双端</strong>列表，而且还提供了从左右两端阻塞获取元素的方法,其实就是可以作为消息队列使用。列表元素有序可重复。</li><li><code>rpush/lpush/linsert key value</code> ： 从左边/右边/插入位置添加元素</li><li><code>lrange/lindex/llen key [start] [end]/[index]</code> : 获取指定范围的元素集/获取指定下表的元素/集合长度</li><li><code>lpop/rpop/lrem/ltrim key /[start] [end]</code> : 左右端弹出元素/裁剪列表(返回指定顺序或者排序的列表)</li><li><code>blpop/brpop key</code> : 阻塞式地弹出元素<ul><li>实现生产-消费者的方式</li></ul></li><li><strong>使用场景</strong>：<ul><li>消息队列 ： lpush + brpop 可以实现阻塞队列，但是并不推荐使用。</li><li>有限集合： lpush + ltrim 显示<strong>最新</strong>入队的元素信息</li><li>栈： lpush + lpop</li></ul></li></ul></li><li><strong>set</strong> :<ul><li>不允许重复元素的数据集合，无序存储。支持取<strong>交集，并集，差集</strong>等功能，最多存储2^32 - 1 个元素</li><li><code>sadd/srem/scard/smembers key</code> : 添加，删除，计算元素个数，显示集合元素</li><li><code>sinter/sunion/sdiff key1 key2 key3...</code> : 在多个key中取交集，并集，差集</li><li><code>sinterstore/sunionstore/sdiffstore destinationKey key1 key2 key3</code> : 将交集，并集，差集的结果保存在 destinationKey中</li></ul></li><li><strong>zset</strong>:<ul><li>有序集合，通过给key添加一个 score 达到排序的目的</li><li><code>zadd/zcard/zscore/zrank/zrem/</code> key score menber score1 menber1 score2 menber2: 增加，计数，排序删除</li><li><code>zrange/zrevrange/zrangebyscore/zrevrangebyscore key start end</code> : 指定score范围的元素</li><li><code>zcount key min max</code> : 返回指定分数范围的元素</li><li><code>zremrangebyrank key start end</code> : 删除指定排名内的升序元素<ul><li>zremrangebyrank user:ranking 0 2</li></ul></li></ul></li></ul><h3 id="持久化："><a href="#持久化：" class="headerlink" title="持久化："></a>持久化：</h3><ul><li><p>概述：Redis提供两种持久化方式： RDB(全量复制)，AOF(增量复制)。</p></li><li><p><strong>RDB</strong> ：</p><ul><li>RDB 持久化是把当前进程数据生成快照保存到硬盘的过程，触发RDB持久化的过程有手动和自动</li><li><strong>自动触发</strong>：<ul><li><code>save m n</code> : 配置项，表示m秒内数据集存在n次修改时，自动触发bgsave</li><li>从节点全量复制，主节点会自动执行bgsave生成RDB文件</li><li>debug reload 操作命令重新加载Redis ，也会触发 save 操作</li><li>默认情况下执行 shutdown 命令，如果没有开启AOF持久化会自动执行bgsave</li></ul></li><li><strong>手动触发</strong>：save 和 bgsave 命令<ul><li><code>save</code> : 阻塞当前Redis 服务器直到RBD持久化完成，很明显，不建议线上使用。</li><li><code>bgsave</code> :<ul><li>执行 bgsave 命令，查看是否有其他子进程在执行bgsave，存在则直接返回。</li><li>父进程执行 fork 操作创建子进程，fork 操作过程中父进程阻塞，info stats 命令的 latest_fork_usec 可以查看最近一次的fork操作耗时，单位为微秒。</li><li>父进程 fork 完成，bgsave 返回 “Background saving started” ，并不再阻塞父进程</li><li>子进程创建RDB文件，根据父进程内存生成临时快照文件，完成后对原有文件进行<strong>原子</strong>替换。执行<code>lastsave</code>命令可以获取最后一次生成RDB的时间，对应info_stats 的 rdb_last_save_time</li><li>子进程告知父进程bgsave完成，父进程更新统计信息</li></ul></li></ul></li><li><strong>RDB文件管理</strong>：<ul><li>dbflename : 指定rdb文件的存储位置</li><li>config set dir {newDir} ,config set dbfilename {newFilename} 动态设置RDB文件和存储位置，之后的RDB会保存到新的位置；动态设置适用于磁盘写满和坏盘的情况</li></ul></li><li><strong>优点</strong>：<ul><li>RDB是一个紧凑的二进制文件，适合做备份和全量复制(数据转移，数据恢复)。</li></ul></li><li><strong>缺点</strong>：<ul><li>无法进行实时持久化和秒级持久化。bgsave每次都需要fork主进程，执行成本高。</li></ul></li></ul></li><li><p><strong>AOF</strong>：Append only file</p><ul><li><p>概述：以独立日志的方式记录每次写命令，重启时再执行AOF文件的命令恢复数据；解决了RDB不能实时持久化和秒级持久化的问题</p></li><li><p><strong>配置</strong>：</p><ul><li><code>appendfileonly : yes|no</code> : 这个配置项表示开启或关闭AOF持久化</li><li><code>appendfilename</code> : AOF文件名称配置</li></ul></li><li><p><strong>AOF过程</strong>：</p><ul><li><p>将所有的写入命令追加到 aof_buf 中</p><blockquote><p>Redis 使用单线程响应命令，如果每次写AOF文件都直接追加到硬盘，性能取决于当前硬盘负载。先写入缓冲区，Redis可以提供多种缓冲区同步硬盘的策略(always,everysec,no)。</p></blockquote></li><li><p>AOF缓冲区根据对应的策略向硬盘做同步操作</p></li><li><p>随着AOF文件越来越大，定期对文件进行重写，压缩文件</p></li><li><p>Redis 服务重启，加载AOF文件进行数据恢复</p></li></ul></li><li><p><strong>缓冲区同步硬盘策略：</strong></p><ul><li><code>always</code> : 每次写入命令都要同步AOF文件，不建议配置</li><li><code>everysec</code> : 每秒写入一次命令到AOF文件，理论上系统宕机可能会丢失1秒的数据</li><li><code>no</code> : 不添加额外控制，由操作系统同步，但是周期不可控，性能提高，没有数据安全性保证</li></ul></li><li><p><strong>触发方式</strong>：</p><ul><li><p>手动触发: 直接调用 bgwriteaof</p></li><li><p>自动触发：</p><ul><li><p>根据<code>auto-aof-rewrite-min-size 和 auto-aof-rewrite-percentage</code> 参数确定自动触发机制</p><ul><li><code>auto-aof-rewrite-min-size</code> ： 运行AOF重写时文件最小体积，默认64M</li><li><code>auto-aof-rewrite-percentage</code> : 代表当前AOF文件空间(aof-current-size) 和 上一次重写后AOF文件空间(aof_base_size)的比值</li></ul><p>触发时机是：<code>aof_current_size &gt; auto_aof_rewrite_min_size &amp;&amp; (aof_current_size-aof_base_size)</code></p><p>​ <code>/aof_base_size&gt;=auto_aof_rewrite_percentage</code></p></li></ul></li></ul></li></ul></li></ul><hr><h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><ul><li><strong>概述</strong> ： 分布式系统为了解决单点问题，通常会把数据复制多个副本部署到其他机器，满足故障恢复和负载均衡需求。Redis 提供了复制功能，实现了相同数据的多个Redis副本。</li><li><strong>复制功能使用</strong><ul><li>配置：<ul><li><strong>建立复制</strong> ： 有三种方式，不过写入配置文件中<ul><li><code>slaveof [masterHost] [masterPort]</code> : 在从节点服务启动配置文件加入这项配置，指定主节点的IP和端口</li><li>redis-server –slaveof [masterHost] [masterPort] : 从节点server命令带有 –slave 命令启动</li><li>运行期间执行 <code>slaveof [masterHost] [masterPort]</code></li><li>可以看出，使用方式的灵活性，常驻配置可以使用配置文件；测试可以使用命令行或者动态配置</li></ul></li><li><strong>断开复制</strong>：<ul><li>从节点执行slaveof no one,从节点会晋升为主节点</li></ul></li><li><strong>从节点只读</strong>：<ul><li>从节点配置 <code>slave-read-only = yes</code>,表示只读模式，也是推荐的使用方式</li></ul></li><li><strong>传输延迟</strong>：<ul><li><code>repl_disable_tcp_nodelay</code> : 关闭时主节点的所有命令都会及时发送给从节点，主从延迟较小；打开时，主节点会合并比较小的TCP数据包从而节省带宽。</li></ul></li></ul></li></ul></li><li><strong>拓扑</strong>：<ul><li>概述：主从模式之间可以有不同的结构，Redis主从复制支持单层或多层复制关系，主要分为三种：一主一从，一主多从，树状主从。</li><li><em>一主一从</em>：<ul><li>最简单的主从结构，主节点故障时从节点提供故障转移支持。</li><li>当主节点<strong>写命令并发较高</strong>且需要持久化时，可以只在从节点上开启AOF，这样既保证了数据安全性同时也避免了持久化对主节点的性能干扰。</li><li><strong>当主节点关闭持久化的时候，如果主节点宕机，需要避免重启，因为重启后的主节点数据集为空，从节点同步会清空数据</strong>，这种情况下应该先断开从节点的主从依赖，然后重启主节点</li></ul></li><li><em>一主多从</em> : 星形拓扑结构<ul><li>一个主节点具有<strong>多个</strong>从节点，实现读写分离。对于读占比较大的场景，可以把读命令发送到从节点来分担主节点压力，同时可以执行一些耗时的命令，例如查找所有key，sort 等慢查询。</li><li>但是对于并发写比较高的场景，一主多从会导致主节点需要多次发送写命令到从节点，消耗更多的网络带宽，同时也增加了主节点的负载影响服务器的稳定性。</li></ul></li><li><em>树状主从</em>：<ul><li>从节点也具备从节点，这样的话主节点只需要将自己的写命令发送到自己的直接从节点，然后再由从节点复制到自身的从节点。挂载多个节点时，避免了对主节点性能的干扰，降低主节点压力。</li></ul></li></ul></li></ul><hr><h3 id="哨兵："><a href="#哨兵：" class="headerlink" title="哨兵："></a>哨兵：</h3><ul><li>概述：Redis 主从模式下，一旦主节点故障不能提供服务，需要将从节点升级为主节点，同时更新主节点地址。这个过程如果手动完成的话，肯定是比较繁琐的，而且故障发生是不确定的。Redis 从2.8版本开始提供了<strong>哨兵(Sentinel)</strong> 来解决这个问题。</li><li>哨兵节点：<ul><li>首先，哨兵节点也是一个redis-server，只是做了一些特殊配置 ，它的功能不是专注于读写数据，而是监控主从节点状态。</li><li>//TODO</li></ul></li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/JAVA/" rel="tag"># JAVA</a> <a href="/tags/NOSQL/" rel="tag"># NOSQL</a> <a href="/tags/缓存/" rel="tag"># 缓存</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/joker/AQS队列同步器-一/" rel="next" title="AQS队列同步器(一)"><i class="fa fa-chevron-left"></i> AQS队列同步器(一)</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/joker/AQS队列同步器-二/" rel="prev" title="AQS队列同步器(二)">AQS队列同步器(二) <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"></div></div></div><div class="comments" id="comments"></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview">站点概览</li></ul><section class="site-overview sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/uploads/avatar.jpg" alt="Joker Zou"><p class="site-author-name" itemprop="name">Joker Zou</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">10</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">2</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">11</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="links-of-author motion-element"></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-学习笔记-一"><span class="nav-number">1.</span> <span class="nav-text">Redis 学习笔记(一)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#简述"><span class="nav-number">1.1.</span> <span class="nav-text">简述.</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-优点："><span class="nav-number">1.2.</span> <span class="nav-text">Redis 优点：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redsi缺点"><span class="nav-number">1.3.</span> <span class="nav-text">Redsi缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-数据结构："><span class="nav-number">1.4.</span> <span class="nav-text">Redis 数据结构：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#持久化："><span class="nav-number">1.5.</span> <span class="nav-text">持久化：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#复制"><span class="nav-number">1.6.</span> <span class="nav-text">复制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#哨兵："><span class="nav-number">1.7.</span> <span class="nav-text">哨兵：</span></a></li></ol></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2019</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Joker Zou</span></div><div class="powered-by">由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动</div><div class="theme-info">主题 - <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script><script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script><script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script></body></html>