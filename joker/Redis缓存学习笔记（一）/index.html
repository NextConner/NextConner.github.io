<!DOCTYPE html><html class="theme-next gemini use-motion" lang="zh-Hans,US,JP,default"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css"><meta name="keywords" content="JAVA,NOSQL,缓存,"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2"><meta name="description" content="¶Redis 学习笔记(一)¶简述.Redis (Remote Dictionary Server) ，是一个基于内存的高性能Key-Value数据库；支持多种丰富的数据类型，而且由于纯内存访问和优秀的单线程架构，所以具备很高的响应性。支持主从模式，在单机多机环境下分别支持哨兵和集群搭建高可用环境。¶Redis 优点：访问速度快： Redis 将数据保存在内存中，存取速度比较可观；并且可以定期通过"><meta name="keywords" content="JAVA,NOSQL,缓存"><meta property="og:type" content="article"><meta property="og:title" content="Redis缓存学习笔记（一）"><meta property="og:url" content="https://NextConner.github.io/joker/Redis缓存学习笔记（一）/index.html"><meta property="og:site_name" content="Joker With Time Passing!"><meta property="og:description" content="¶Redis 学习笔记(一)¶简述.Redis (Remote Dictionary Server) ，是一个基于内存的高性能Key-Value数据库；支持多种丰富的数据类型，而且由于纯内存访问和优秀的单线程架构，所以具备很高的响应性。支持主从模式，在单机多机环境下分别支持哨兵和集群搭建高可用环境。¶Redis 优点：访问速度快： Redis 将数据保存在内存中，存取速度比较可观；并且可以定期通过"><meta property="og:locale" content="zh-Hans"><meta property="og:updated_time" content="2019-08-03T01:43:01.569Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Redis缓存学习笔记（一）"><meta name="twitter:description" content="¶Redis 学习笔记(一)¶简述.Redis (Remote Dictionary Server) ，是一个基于内存的高性能Key-Value数据库；支持多种丰富的数据类型，而且由于纯内存访问和优秀的单线程架构，所以具备很高的响应性。支持主从模式，在单机多机环境下分别支持哨兵和集群搭建高可用环境。¶Redis 优点：访问速度快： Redis 将数据保存在内存中，存取速度比较可观；并且可以定期通过"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Gemini",sidebar:{position:"left",display:"post",offset:12,offset_float:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!0,tabs:!0,motion:!0,duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="https://NextConner.github.io/joker/Redis缓存学习笔记（一）/"><title>Redis缓存学习笔记（一） | Joker With Time Passing!</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">Joker With Time Passing!</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">Boy meets ambitions!</p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://NextConner.github.io/joker/Redis缓存学习笔记（一）/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Joker Zou"><meta itemprop="description" content><meta itemprop="image" content="/uploads/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Joker With Time Passing!"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Redis缓存学习笔记（一）</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-23T22:13:13+08:00">2019-07-23 22:13:13 </time></span><span class="post-updated">&nbsp; | &nbsp; 更新于 <time itemprop="dateUpdated" datetime="2019-08-03T09:43:01+08:00" content="2019-08-03 09:43:01">2019-08-03 09:43:01 </time></span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/笔记/" itemprop="url" rel="index"><span itemprop="name">笔记</span> </a></span></span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><a href="/joker/Redis缓存学习笔记（一）/#comments" itemprop="discussionUrl"><span class="post-comments-count disqus-comment-count" data-disqus-identifier="joker/Redis缓存学习笔记（一）/" itemprop="commentCount"></span> </a></span><span class="post-meta-divider">|</span> <span class="page-pv"><i class="fa fa-file-o"></i> 阅读数 <span class="busuanzi-value" id="busuanzi_value_page_pv"></span></span><div class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">字数统计</span> <span class="post-count" title="字数统计">6.1k 字 </span><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长</span> <span title="阅读时长">21 分钟</span></div></div></header><div class="post-body" itemprop="articleBody"><h2 id="Redis-学习笔记-一"><a class="header-anchor" href="#Redis-学习笔记-一">¶</a>Redis 学习笔记(一)</h2><hr><h3 id="简述"><a class="header-anchor" href="#简述">¶</a>简述.</h3><ul><li><strong>Redis</strong> (Remote Dictionary Server) ，是一个基于<strong>内存</strong>的高性能Key-Value数据库；支持多种丰富的数据类型，而且由于纯内存访问和优秀的单线程架构，所以具备很高的响应性。支持<strong>主从模式</strong>，在单机多机环境下分别支持<strong>哨兵</strong>和<strong>集群</strong>搭建高可用环境。</li></ul><hr><h3 id="Redis-优点："><a class="header-anchor" href="#Redis-优点：">¶</a>Redis 优点：</h3><ul><li><p><strong>访问速度快：</strong> Redis 将数据保存在内存中，存取速度比较可观；并且可以定期通过异步操作将数据库数据持久化到本地磁盘，作为灾难恢复和数据转移的准备。</p></li><li><p><strong>支持丰富的数据结构：</strong> Redis 大受欢迎的原因还在于它提供了丰富的数据结构:string,hash,list,set,zset,Pub/Sub,Geo等，可以很大程度上直接满足业务场景的需求。</p></li><li><p><strong>丰富的特性：</strong></p><ul><li><p>支持简单的发布订阅</p></li><li><p>Key过期策略：在缓存一致性问题中可以提供帮助</p></li><li><p>事务特性</p></li><li><p>支持多DB:16个，从0开始</p></li><li><p>原子计数</p></li><li><p>Session 共享</p></li><li><p>分布式锁</p><p>…</p><a id="more"></a></li></ul></li><li><p><strong>持久化存储：</strong> RDB，AOF</p></li></ul><h3 id="Redsi缺点"><a class="header-anchor" href="#Redsi缺点">¶</a>Redsi缺点</h3><ul><li>内存存储所以受到机器本身的内存限制，需要制定数据的定期清除策略等</li><li><strong>RDB</strong>会占用主机CPU，导致Redis 卡顿等。</li><li>修改配置文件，重启服务，预热大量数据时间比较久，期间Redis 不能提供服务</li></ul><h3 id="Redis-数据结构："><a class="header-anchor" href="#Redis-数据结构：">¶</a>Redis 数据结构：</h3><ul><li>概述: Redis 提供了 string(字符串)，hash，list(列表)，set(集合)，zset(顺序集合)这些基本数据类型，以及在此基础上构建的复杂类型。</li><li><strong>string</strong> :<ul><li>字符串是 Redis 最基础的数据结构，在Redis 中，key 都是字符串类型，其他几种类型都是在字符串的基础上构建的。虽然是字符串类型，但实际的值可以是多种形式的字符串：json,xml,数字，二进制等，最大值限制是512M.</li><li><code>set key value [过期时间] [毫秒数] [NX|XX]</code> : 因为在单机环境下，redis 的分布式锁可以通过它实现。<ul><li>set 命令带上过期时间参数和NX ，表示设置一个具有时限的独占锁。</li><li>过期时间防止忘记释放锁导致后来者无法获取锁；NX表示key不存在才会创建，也就是只有一个锁。</li><li>这条命令的简化版本是 <code>setnx,setex</code>，可以保证原子性的形况下才能一起使用实现分布式锁。</li></ul></li><li><code>mget/mset</code> : 批量操作命令<ul><li>设想一个执行n次get命令的场景：每一次get都需要发送一次请求，等待一次返回(单线程模型)，效率不高</li><li>mget 命令只会发送一次请求，然后等待服务端一次执行n次get之后将结果全部返回，节省了<strong>网络IO</strong>时间</li><li>需要注意批量操作的数据量限制，如果超过带宽或者其他资源瓶颈，可能会出现网络拥塞等问题。</li></ul></li><li><code>incr/incrby/decr/decrby key [num]</code> : 对于内容是数字类型的key进行增减和指定参数的增减<ul><li>当 value 值是数字类型的时候，可以使用这些命令进行增减</li><li>非数字类型value会报错</li><li>不存在的key会被创建并增加，这一点需要注意，它并不会因为key不存在而返回null</li></ul></li><li><strong>string类型内部编码</strong>：根据实际存储的<strong>值类型和长度</strong>使用不同的内部编码实现<ul><li>int : 8字节的长整型</li><li>embstr : 小于等于39个字节的字符串</li><li>raw : 大于 39 字节的字符串</li></ul></li></ul></li><li><strong>hash</strong> :<ul><li>和其他数据结构可能有点不一样，Redis 本身是key-value存储，hash结构的键又是一个key-value类型，类似于：user:1:name -tom,适合用来表示对象类型。哈希的映射关系叫做 field-value，value 不是指键对应得值，而是field对应的值。</li><li><code>hget/hset/hdel/ key field value</code> ： hset user:name tom<ul><li>基本的命令，hdel 可以删除多个dield ： hdel key [f1,f2,f3…]</li></ul></li><li><code>hmget/hmset/hkeys/hvals</code> : 批量设置/获取/获取键/获取值等命令</li></ul></li><li><strong>list</strong> :<ul><li>列表，<strong>有序存储多个字符串</strong>，是个<strong>双端</strong>列表，而且还提供了从左右两端阻塞获取元素的方法,其实就是可以作为消息队列使用。列表元素有序可重复。</li><li><code>rpush/lpush/linsert key value</code> ： 从左边/右边/插入位置添加元素</li><li><code>lrange/lindex/llen key [start] [end]/[index]</code> : 获取指定范围的元素集/获取指定下表的元素/集合长度</li><li><code>lpop/rpop/lrem/ltrim key /[start] [end]</code> : 左右端弹出元素/裁剪列表(返回指定顺序或者排序的列表)</li><li><code>blpop/brpop key</code> : 阻塞式地弹出元素<ul><li>实现生产-消费者的方式</li></ul></li><li><strong>使用场景</strong>：<ul><li>消息队列 ： lpush + brpop 可以实现阻塞队列，但是并不推荐使用。</li><li>有限集合： lpush + ltrim 显示<strong>最新</strong>入队的元素信息</li><li>栈： lpush + lpop</li></ul></li></ul></li><li><strong>set</strong> :<ul><li>不允许重复元素的数据集合，无序存储。支持取<strong>交集，并集，差集</strong>等功能，最多存储2^32 - 1 个元素</li><li><code>sadd/srem/scard/smembers key</code> : 添加，删除，计算元素个数，显示集合元素</li><li><code>sinter/sunion/sdiff key1 key2 key3...</code> : 在多个key中取交集，并集，差集</li><li><code>sinterstore/sunionstore/sdiffstore destinationKey key1 key2 key3</code> : 将交集，并集，差集的结果保存在 destinationKey中</li></ul></li><li><strong>zset</strong>:<ul><li>有序集合，通过给key添加一个 score 达到排序的目的</li><li><code>zadd/zcard/zscore/zrank/zrem/</code> key score menber score1 menber1 score2 menber2: 增加，计数，排序删除</li><li><code>zrange/zrevrange/zrangebyscore/zrevrangebyscore key start end</code> : 指定score范围的元素</li><li><code>zcount key min max</code> : 返回指定分数范围的元素</li><li><code>zremrangebyrank key start end</code> : 删除指定排名内的升序元素<ul><li>zremrangebyrank user:ranking 0 2</li></ul></li></ul></li></ul><h3 id="持久化："><a class="header-anchor" href="#持久化：">¶</a>持久化：</h3><ul><li><p>概述：Redis提供两种持久化方式： RDB(全量复制)，AOF(增量复制)。</p></li><li><p><strong>RDB</strong> ：</p><ul><li>RDB 持久化是把当前进程数据生成快照保存到硬盘的过程，触发RDB持久化的过程有手动和自动</li><li><strong>自动触发</strong>：<ul><li><code>save m n</code> : 配置项，表示m秒内数据集存在n次修改时，自动触发bgsave</li><li>从节点全量复制，主节点会自动执行bgsave生成RDB文件</li><li>debug reload 操作命令重新加载Redis ，也会触发 save 操作</li><li>默认情况下执行 shutdown 命令，如果没有开启AOF持久化会自动执行bgsave</li></ul></li><li><strong>手动触发</strong>：save 和 bgsave 命令<ul><li><code>save</code> : 阻塞当前Redis 服务器直到RBD持久化完成，很明显，不建议线上使用。</li><li><code>bgsave</code> :<ul><li>执行 bgsave 命令，查看是否有其他子进程在执行bgsave，存在则直接返回。</li><li>父进程执行 fork 操作创建子进程，fork 操作过程中父进程阻塞，info stats 命令的 latest_fork_usec 可以查看最近一次的fork操作耗时，单位为微秒。</li><li>父进程 fork 完成，bgsave 返回 “Background saving started” ，并不再阻塞父进程</li><li>子进程创建RDB文件，根据父进程内存生成临时快照文件，完成后对原有文件进行<strong>原子</strong>替换。执行<code>lastsave</code>命令可以获取最后一次生成RDB的时间，对应info_stats 的 rdb_last_save_time</li><li>子进程告知父进程bgsave完成，父进程更新统计信息</li></ul></li></ul></li><li><strong>RDB文件管理</strong>：<ul><li>dbflename : 指定rdb文件的存储位置</li><li>config set dir {newDir} ,config set dbfilename {newFilename} 动态设置RDB文件和存储位置，之后的RDB会保存到新的位置；动态设置适用于磁盘写满和坏盘的情况</li></ul></li><li><strong>优点</strong>：<ul><li>RDB是一个紧凑的二进制文件，适合做备份和全量复制(数据转移，数据恢复)。</li></ul></li><li><strong>缺点</strong>：<ul><li>无法进行实时持久化和秒级持久化。bgsave每次都需要fork主进程，执行成本高。</li></ul></li></ul></li><li><p><strong>AOF</strong>：Append only file</p><ul><li><p>概述：以独立日志的方式记录每次写命令，重启时再执行AOF文件的命令恢复数据；解决了RDB不能实时持久化和秒级持久化的问题</p></li><li><p><strong>配置</strong>：</p><ul><li><code>appendfileonly : yes|no</code> : 这个配置项表示开启或关闭AOF持久化</li><li><code>appendfilename</code> : AOF文件名称配置</li></ul></li><li><p><strong>AOF过程</strong>：</p><ul><li><p>将所有的写入命令追加到 aof_buf 中</p><blockquote><p>Redis 使用单线程响应命令，如果每次写AOF文件都直接追加到硬盘，性能取决于当前硬盘负载。先写入缓冲区，Redis可以提供多种缓冲区同步硬盘的策略(always,everysec,no)。</p></blockquote></li><li><p>AOF缓冲区根据对应的策略向硬盘做同步操作</p></li><li><p>随着AOF文件越来越大，定期对文件进行重写，压缩文件</p></li><li><p>Redis 服务重启，加载AOF文件进行数据恢复</p></li></ul></li><li><p><strong>缓冲区同步硬盘策略：</strong></p><ul><li><code>always</code> : 每次写入命令都要同步AOF文件，不建议配置</li><li><code>everysec</code> : 每秒写入一次命令到AOF文件，理论上系统宕机可能会丢失1秒的数据</li><li><code>no</code> : 不添加额外控制，由操作系统同步，但是周期不可控，性能提高，没有数据安全性保证</li></ul></li><li><p><strong>触发方式</strong>：</p><ul><li><p>手动触发: 直接调用 bgwriteaof</p></li><li><p>自动触发：</p><ul><li><p>根据<code>auto-aof-rewrite-min-size 和 auto-aof-rewrite-percentage</code> 参数确定自动触发机制</p><ul><li><code>auto-aof-rewrite-min-size</code> ： 运行AOF重写时文件最小体积，默认64M</li><li><code>auto-aof-rewrite-percentage</code> : 代表当前AOF文件空间(aof-current-size) 和 上一次重写后AOF文件空间(aof_base_size)的比值</li></ul><p>触发时机是：<code>aof_current_size &gt; auto_aof_rewrite_min_size &amp;&amp; (aof_current_size-aof_base_size)</code></p><p>​ <code>/aof_base_size&gt;=auto_aof_rewrite_percentage</code></p></li></ul></li></ul></li></ul></li></ul><hr><h3 id="复制"><a class="header-anchor" href="#复制">¶</a>复制</h3><ul><li><strong>概述</strong> ： 分布式系统为了解决单点问题，通常会把数据复制多个副本部署到其他机器，满足故障恢复和负载均衡需求。Redis 提供了复制功能，实现了相同数据的多个Redis副本。</li><li><strong>复制功能使用</strong><ul><li>配置：<ul><li><strong>建立复制</strong> ： 有三种方式，不过写入配置文件中<ul><li><code>slaveof [masterHost] [masterPort]</code> : 在从节点服务启动配置文件加入这项配置，指定主节点的IP和端口</li><li>redis-server --slaveof [masterHost] [masterPort] : 从节点server命令带有 --slave 命令启动</li><li>运行期间执行 <code>slaveof [masterHost] [masterPort]</code></li><li>可以看出，使用方式的灵活性，常驻配置可以使用配置文件；测试可以使用命令行或者动态配置</li></ul></li><li><strong>断开复制</strong>：<ul><li>从节点执行slaveof no one,从节点会晋升为主节点</li></ul></li><li><strong>从节点只读</strong>：<ul><li>从节点配置 <code>slave-read-only = yes</code>,表示只读模式，也是推荐的使用方式</li></ul></li><li><strong>传输延迟</strong>：<ul><li><code>repl_disable_tcp_nodelay</code> : 关闭时主节点的所有命令都会及时发送给从节点，主从延迟较小；打开时，主节点会合并比较小的TCP数据包从而节省带宽。</li></ul></li></ul></li></ul></li><li><strong>拓扑</strong>：<ul><li>概述：主从模式之间可以有不同的结构，Redis主从复制支持单层或多层复制关系，主要分为三种：一主一从，一主多从，树状主从。</li><li><em>一主一从</em>：<ul><li>最简单的主从结构，主节点故障时从节点提供故障转移支持。</li><li>当主节点<strong>写命令并发较高</strong>且需要持久化时，可以只在从节点上开启AOF，这样既保证了数据安全性同时也避免了持久化对主节点的性能干扰。</li><li><strong>当主节点关闭持久化的时候，如果主节点宕机，需要避免重启，因为重启后的主节点数据集为空，从节点同步会清空数据</strong>，这种情况下应该先断开从节点的主从依赖，然后重启主节点</li></ul></li><li><em>一主多从</em> : 星形拓扑结构<ul><li>一个主节点具有<strong>多个</strong>从节点，实现读写分离。对于读占比较大的场景，可以把读命令发送到从节点来分担主节点压力，同时可以执行一些耗时的命令，例如查找所有key，sort 等慢查询。</li><li>但是对于并发写比较高的场景，一主多从会导致主节点需要多次发送写命令到从节点，消耗更多的网络带宽，同时也增加了主节点的负载影响服务器的稳定性。</li></ul></li><li><em>树状主从</em>：<ul><li>从节点也具备从节点，这样的话主节点只需要将自己的写命令发送到自己的直接从节点，然后再由从节点复制到自身的从节点。挂载多个节点时，避免了对主节点性能的干扰，降低主节点压力。</li></ul></li></ul></li></ul><hr><h3 id="哨兵-Sentinel-："><a class="header-anchor" href="#哨兵-Sentinel-：">¶</a>哨兵(Sentinel)：</h3><ul><li>概述：Redis 主从模式下，一旦主节点故障不能提供服务，需要将从节点升级为主节点，同时更新主节点地址。这个过程如果手动完成的话，肯定是比较繁琐的，而且故障发生是不确定的。Redis 从2.8版本开始提供了<strong>哨兵(Sentinel)</strong> 来解决这个问题。</li><li>哨兵节点：<ul><li>哨兵节点也是一个redis-server，只是做了一些特殊配置 ，它的功能不是专注于读写数据，而是监控主节点状态；当确认主节点下线(主观下线或者客观下线)，会将从节点升级为主节点，其他的从节点从新的主节点进行复制；主节点降级为从节点，重连后从新的主节点复制</li><li>它实现了故障发现和故障转移，并通知应用方，从而实现真正的高可用</li></ul></li><li><strong>工作方式</strong>：<ul><li>每个Sentinel节点以每秒钟一次的频率向它所知的Master(主节点)，Slave(从节点)以及其他Sentinel节点实例发送一个PING命令，判断它们的上下线状态</li><li>如果一个实例距离最后一次有效回复PING命令的时间超过 <code>down-after-milliseconds</code> 指定的值，这个实例就会被Sentinel节点标记为<strong>主观下线</strong></li><li>如果一个Master被标记为主观下线，则正在监视这个Master的所有Sentinel节点要以每秒一次的频率确认Master的确进入了主观下线状态</li><li>当有足够数量的Sentinel节点在指定的时间范围内确认Master的确进入了主观下线状态，Master节点会被标记为客观下线</li><li>一般情况下，每个Sentinel节点是以每10 s 一次的频率向它所有已知的 Master，Slave 节点发送INFO命令</li><li>当Master被Sentinel节点标记为客观下线时，Sentinel节点向下线的Master的所有Slave发送INFO信息的频率会从10s一次改为1s一次</li><li>如果没有足够数量的Sentinel节点同意Master节点已经下线，Master的客观下线状态就会被移除；同样，如果Master重新向 Sentinel 的 PING 命令返回有效回复，Master的主观下线状态就会被移除</li></ul></li><li></li></ul><hr><h3 id="Redis-数据淘汰策略"><a class="header-anchor" href="#Redis-数据淘汰策略">¶</a>Redis 数据淘汰策略</h3><ul><li><p>概述：之前说到Redis 是基于内存存储所以访问速度快，同时也正是因为 内存存储，可存储的数据量受到单机内存大小的限制。因此通常会过期Redis 内的数据，以节省内存空间。</p></li><li><p>Redis 数据过期策略有三种：</p><ul><li>被动删除</li><li>主动删除</li><li>超过<code>maxmemory</code>配置项大小限制，触发主动清理策略</li></ul></li><li><p><strong>被动删除</strong>：</p><ul><li>Redis 中可以设置带有过期时间的key，但是，这只代表key在过期之后，无法再从Redis 获得，值仍然是存在内存中的。对于这种形式过期的key值，当<strong>下一次访问它</strong>，发现它过期的时候，会从内存中删除。</li><li>好处很明显，因为是个被动的动作，没有主动去扫描内存中过期的key，不会有额外的CPU占用；</li><li>坏处也同样很明显，假设存在大量的短时间使用了一次就过期的key值，之后没有再访问它，那么直到他们被淘汰之前，都会占据内存空间。</li></ul></li><li><p><strong>主动删除</strong>：</p><ul><li><p>被动删除是惰性策略，可能会导致过期key值仍然存在在内存中一段时间。主动删除是通过服务器定期对自身资源和状态的检查，并进行必要的清理，使自身达到一个相对稳定健康的状态，这被称为<strong>常规操作(cron job)</strong></p></li><li><p>实现方式： 由配置文件的<code>hz</code> 配置项控制，参考 hz 配置参数的说明:</p><blockquote><p>Redis 会调用内部方法执行一系列的后台任务，包括关闭超时的客户端连接，清洗不再请求的过期key等。</p><p>并不是所有的任务执行频率都一样，但是Redis 通过 <code>hz</code> 参数设置来控制他们的执行。</p><p>hz 参数默认是10，表示10s运行一次。当Redis空闲的时候会使用大量的CPU去清理无效的键值，但是如果恰好存在大量的过期key被清除，会提高Redis 的响应度。</p><p>hz 参数的取值范围在1~500，但是不要超过100。使用建议是，大部分情况下默认10即可，在低延迟的环境中可以设置到100.</p></blockquote></li><li><p>主动删除过期key，只是Redis后台任务的一部分，设置合理的<code>hz</code>参数，能够得到比较好的内存清理效果。</p></li></ul></li><li><p><strong>超过 maxmemory 限制</strong></p><ul><li>当前已使用内存超过 <code>maxmemory</code>限制时，会触发<strong>主动清理</strong>策略，有以下几种：<ul><li><code>volatile-lru</code> : 值对设置了过期时间的key进行LRU</li><li><code>allkeys-lru</code> : 删除lru算法的key</li><li><code>volatile-random</code> : 随即删除即将过期的key</li><li><code>allkeys-random</code> : 随即删除key</li><li><code>volatile-ttl</code> : 删除即将过期的key</li><li><code>noeviction</code>: 永不过期，这时候对于所有的读写请求都会返回错误，并且会触发 <code>freeMemoryIfNeeded(void)</code> 函数清理超出的内存。这个过程是<strong>阻塞</strong>的。</li></ul></li><li><strong>小结</strong>：<ul><li>尽量不要超过 <code>maxmemory</code>的限制，可以适当提高<code>hz</code>参数的值，增加淘汰无效键值的频率。</li><li>不建议将所有的key都设置为<strong>不过期</strong>，一定要根据实际的业务场景考虑：常驻的菜单项可以不过期，热门商品则实要定期更新的，需要设置过期时间。</li></ul></li></ul></li></ul><hr><h3 id="缓存一致性"><a class="header-anchor" href="#缓存一致性">¶</a>缓存一致性</h3><ul><li><p>概述：因为计算机不同存储介质存在读取速度的差异，所以需要通过某种方式弱化这种情况的影响。<strong>缓存的目的是把读写速度慢的介质的数据，保存到读写速度快的介质中，从而提高这一部分数据的读写速度。</strong></p></li><li><p><strong>缓存常见问题:</strong> 其实就是要保证各种突发情况下，缓存仍然有效且能够提供正确的数据保障。</p><ul><li>缓存何时写入以及如何避免重复写入</li><li>缓存如何失效</li><li>缓存和DB的<strong>一致性</strong>如何保证</li><li>缓存穿透</li><li>缓存击穿</li><li>缓存雪崩</li></ul></li><li><p><strong>缓存穿透</strong> ： 1.key值不存在；2.同时发生大量并发请求</p><ul><li>从缓存写入的时机来考虑：先查询缓存，缓存不存在数据，查询数据库，然后写入缓存，返回数据。缓存穿透是指查询一个<strong>不存在的key</strong>,这样每次缓存都<strong>不会命中</strong>，每次都会去查询数据库，缓存也就没有任何意义，等于不存在。在大流量(高峰期和恶意攻击)的情况下，DB没有那么好的性能，可能就会挂掉。</li><li>解决方式：<ul><li>因为查询不存在key,所以返回了空结果，需要去查询数据库。那么，如果DB中的数据也为空，可以直接对这个key缓存一个空对象，这样每次请求缓存都会获得空对象，不会再查询数据库。</li><li>给缓存层额外增加一个BloomFilter过滤器//TODO</li></ul></li><li>可行性：<ul><li><strong>缓存空对象</strong> ：这种方式的问题在于，如果存在大量key为空，仍然会占据内存，需要一定的缓存空间。适用于缓存命中不高的场景，代码实现也比较简单</li><li><strong>BloomFilter 过滤器</strong>：//TODO</li></ul></li></ul></li><li><p><strong>缓存击穿：</strong> 1.key存在，过期了 ； 2.大量的并发请求</p><ul><li><p>概述：和缓存穿透不一样的是，这个key是真实存在的，只是在某个时间点<strong>恰好</strong>不可用了，这个时候的大量请求缓存都无法命中，所有都会去查询DB，DB可能因此而挂掉。</p></li><li><p>解决方式：</p><ul><li><p><strong>互斥锁锁</strong>： 当缓存不存在的时候，在去查询DB之前要求先获得一个互斥锁，保证只有一个线程去查询DB，并且更新到缓存，步骤如下：</p><ul><li><p>获取分布式锁，直到请求成功</p></li><li><p>再去查询缓存(注意，不是拿到锁就直接查询DB)，如果值存在，直接返回；值不存在，再去查询DB，然后更新到缓存</p></li><li><p>更新缓存</p></li></ul></li><li><p><strong>手动过期</strong>：缓存不设置过期时间，将过期时间保存在key对应的value里面，如果定时扫描发现key将要过期，通过一个后台线程异步进行缓存更新，保证只有一个线程去更新缓存</p></li></ul></li><li><p>可行性：</p><ul><li><p><strong>互斥锁</strong>：可以保证数据一致性，但是代码复杂，而且不正确的实现会导致死锁。</p><blockquote><p>单机Redis 分布式锁实现，可以通过 set(key,value,NX,EX,expireTime)的原子指令完成，NX表示key不存在进行新增，EX表示key会在expireTime之后过期。</p></blockquote></li><li><p><strong>手动过期</strong>：异步线程所有用户无感，但是由于扫描任务不会十分精确，会有数据不一致问题。</p></li></ul></li></ul></li><li><p><strong>缓存雪崩</strong>：缓存不可用</p><ul><li>概述：缓存雪崩是指某种情况下缓存服务挂掉(进程被杀死，服务器停电)，那么所有的请求都会去DB查询数据，大流量可能会压垮DB。</li><li>解决方案：<ul><li>搭建缓存高可用，Redis 有 RedisSentinel 和 集群两种方式可以选择。</li><li>本地缓存：等于拥有两层缓存，Redis挂掉还可以将缓存写入本地，等待Redis服务恢复重新提供服务。</li><li>//TODO</li></ul></li></ul></li><li><p><strong>缓存和DB的数据一致性保证</strong>：</p><ul><li>概述：考虑这样的场景：当缓存被A线程过期，B线程发现缓存为空，查询DB更新到缓存，然后A线程更新DB再次更新缓存，B线程查询的就是旧数据，在并发的场景下这种情况有可能会发生的。或者更新DB和更新缓存的操作不是原子的，一个成功一个失败，也会导致错误数据的残留。</li><li><strong>缓存更新的方式</strong> ：<ul><li><strong>先把数据存到数据库，成功后，失效缓存</strong><ul><li>从并发的场景来考虑：当A线程查询数据，B线程更新数据，在B线程<strong>更新数据库之后，失效缓存之前</strong>，如果A线程从缓存中取到了值，那就会获取到一个旧值。而随后的线程都可以获取新的值</li><li>但是，如果DB和缓存的操作不是原子的，更新数据库成功，失效缓存失败，会导致缓存中一致存在旧数据。</li></ul></li><li><strong>先淘汰缓存，再更新数据库</strong>：<ul><li>这个好处是，数据的最终一致性可以得到保障，只要先淘汰了缓存，之后至少得有一次成功的写数据库更新缓存，所以最终数据是一致的。</li><li>但是DB和缓存之间还是存在数据不一致，例如A线程淘汰缓存之后，更新数据库之前，B线程查询缓存不命中，查询DB然后更新到缓存，随后A线程更新数据库，那缓存和DB还是数据不一致，导致不一致的原因就在于<strong>并发</strong>；</li><li>解决并发带来的出行顺序不一致问题，通常都会想到加锁，让并行执行变成串行执行，但是需要注意获取锁时机<ul><li>写请求时，先淘汰缓存之前，获取锁，这样就不存在其他线程查询缓存的情况</li><li>读请求时，<strong>缓存不命中</strong>，先获取锁，然后去查询DB</li></ul></li></ul></li></ul></li><li><strong>建议</strong>：<ul><li>可以对缓采用双淘汰机制：更新数据库之前淘汰缓存，然后设置一定的短时间超时限制。这样首先保证缓存会被更新一次，假设存入了并发产生的脏数据，也会在段时间后过期，重新获取DB的新数据。(前提是业务场景能够接受短时间的数据不一致。)</li></ul></li></ul></li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/JAVA/" rel="tag"># JAVA</a> <a href="/tags/NOSQL/" rel="tag"># NOSQL</a> <a href="/tags/缓存/" rel="tag"># 缓存</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/joker/AQS队列同步器-一/" rel="next" title="AQS队列同步器(一)"><i class="fa fa-chevron-left"></i> AQS队列同步器(一)</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/joker/AQS队列同步器-二/" rel="prev" title="AQS队列同步器(二)">AQS队列同步器(二) <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"></div></div></div><div class="comments" id="comments"><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview">站点概览</li></ul><section class="site-overview sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/uploads/avatar.jpg" alt="Joker Zou"><p class="site-author-name" itemprop="name">Joker Zou</p><p class="site-description motion-element" itemprop="description">Follow your heart</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">23</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">4</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">28</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="links-of-author motion-element"></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-学习笔记-一"><span class="nav-number">1.</span> <span class="nav-text">¶Redis 学习笔记(一)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#简述"><span class="nav-number">1.1.</span> <span class="nav-text">¶简述.</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-优点："><span class="nav-number">1.2.</span> <span class="nav-text">¶Redis 优点：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redsi缺点"><span class="nav-number">1.3.</span> <span class="nav-text">¶Redsi缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-数据结构："><span class="nav-number">1.4.</span> <span class="nav-text">¶Redis 数据结构：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#持久化："><span class="nav-number">1.5.</span> <span class="nav-text">¶持久化：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#复制"><span class="nav-number">1.6.</span> <span class="nav-text">¶复制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#哨兵-Sentinel-："><span class="nav-number">1.7.</span> <span class="nav-text">¶哨兵(Sentinel)：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-数据淘汰策略"><span class="nav-number">1.8.</span> <span class="nav-text">¶Redis 数据淘汰策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缓存一致性"><span class="nav-number">1.9.</span> <span class="nav-text">¶缓存一致性</span></a></li></ol></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="copyright">&copy; <span itemprop="copyrightYear">2020</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Joker Zou</span></div><div class="powered-by">由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动</div><div class="theme-info">主题 - <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a></div><div class="busuanzi-count"><script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="site-uv">访客数 <span class="busuanzi-value" id="busuanzi_value_site_uv"></span> 只 </span><span class="site-pv"><i class="fa fa-eye"></i> 总访问量 <span class="busuanzi-value" id="busuanzi_value_site_pv"></span> 回</span></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script><script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script><script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script><script id="dsq-count-scr" src="https://jokerz.disqus.com/count.js" async></script><script type="text/javascript">var disqus_config=function(){this.page.url="https://NextConner.github.io/joker/Redis缓存学习笔记（一）/",this.page.identifier="joker/Redis缓存学习笔记（一）/",this.page.title="Redis缓存学习笔记（一）"},d=document,s=d.createElement("script");s.src="https://jokerz.disqus.com/embed.js",s.setAttribute("data-timestamp",""+ +new Date),(d.head||d.body).appendChild(s)</script></body></html>